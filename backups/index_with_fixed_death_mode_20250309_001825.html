<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chemtrail Fighter</title>
    <!-- 
    PERFORMANCE OPTIMIZATIONS:
    1. Game over threshold set to 7% chemtrail density to prevent slowdown
    2. Added visual warning when approaching 6% chemtrail density
    3. Skip rendering chemtrails that are far off-screen
    -->
    <!-- Add Visitor-like pixel font (Press Start 2P is the closest widely available) -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Visitor';
            src: url('https://dl.dropboxusercontent.com/s/ecgr5oc2k3p9u36/visitor1.ttf?dl=0') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10;
            transition: opacity 0.5s;
        }
        #start-container {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        #start-products {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .product-link {
            transition: transform 0.3s ease;
            display: block;
        }
        .product-link:hover {
            transform: scale(1.05);
        }
        .product-image {
            height: 150px; /* Adjust to match logo height */
            border-radius: 5px;
        }
        #start-btn {
            padding: 20px 40px;
            font-size: 24px;
            background-color: #ffcc00;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            z-index: 12;
        }
        #start-btn:hover {
            transform: scale(1.1);
        }
        #game-logo {
            width: 300px;
            height: auto;
            z-index: 11;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
            filter: blur(5px);
            transition: filter 0.5s ease;
        }
        #game-canvas.active {
            filter: none;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 20px;
            z-index: 5;
            display: none;
        }
        #sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 8px;
            font-size: 20px;
            cursor: pointer;
            z-index: 5;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        #sound-toggle:hover {
            background-color: #000;
            transform: scale(1.05);
        }
        #perf-toggle {
            position: absolute;
            top: 10px;
            right: 60px; /* Position it to the left of the sound toggle */
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            z-index: 5;
            display: none; /* Initially hidden, will be shown when game starts */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s, transform 0.2s;
        }
        #perf-toggle:hover {
            background-color: #000;
            transform: scale(1.05);
        }
        #perf-toggle.active {
            background-color: #2a6e2a; /* Green background when active */
        }
        #upgrades {
            position: absolute;
            top: 10px;
            left: 200px;
            display: none;
            gap: 10px;
            z-index: 5;
        }
        .upgrade-btn {
            padding: 5px 15px;
            font-size: 14px;
            border: 1px solid #fff;
            border-radius: 5px;
            background-color: #666;
            color: #fff;
            cursor: pointer;
            opacity: 0.3;
            transition: opacity 0.3s, background-color 0.3s;
            font-weight: bold;
        }
        .upgrade-btn.active#upgrade-size { opacity: 1; background-color: #bd5704; }
        .upgrade-btn.active#upgrade-style { opacity: 1; background-color: #b00c9f; }
        .upgrade-btn.active#upgrade-shoot { opacity: 1; background-color: #510f7c; }
        .upgrade-btn:hover.active { filter: brightness(1.2); }
        #cheatcode {
            position: absolute;
            top: 10px;
            left: 450px; /* Moved 15px to the right (from 435px) */
            padding: 5px 15px;
            font-size: 14px;
            background-color: #fff;
            color: #000;
            border: none;
            border-radius: 5px;
            z-index: 5;
            display: none;
            width: 150px;
            box-sizing: border-box;
            text-transform: uppercase; /* Force text to display as uppercase */
        }
        #cheatcode:focus {
            outline: none;
        }
        #cheatcode::placeholder {
            color: #999; /* Lighter color for placeholder text */
            opacity: 1; /* Ensure placeholder is visible */
        }
        /* Hide placeholder when user types */
        #cheatcode:not(:placeholder-shown)::placeholder {
            opacity: 0;
        }
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            z-index: 20;
            pointer-events: auto; /* Ensure it captures mouse events */
        }
        #game-over-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #game-over-products {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        #bottom-products {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        #game-over-text {
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 10px;
            max-width: 80%;
        }
        #game-over-text h1 {
            font-size: 64px;
            margin: 0;
            animation: colorChange 3s infinite;
        }
        
        @keyframes colorChange {
            0% { color: #ff0000; } /* Red */
            20% { color: #ffff00; } /* Yellow */
            40% { color: #00ff00; } /* Green */
            60% { color: #00ffff; } /* Cyan */
            80% { color: #ff00ff; } /* Magenta */
            100% { color: #ff0000; } /* Back to red */
        }
        
        #game-over-text p.points {
            font-size: 24px;
            margin: 10px 0;
        }
        #game-over-text p.message {
            font-size: 20px;
            margin: 10px 0;
            line-height: 1.5;
        }
        #play-again-btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ffcc00;
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            margin-bottom: 20px;
        }
        #play-again-btn:hover {
            transform: scale(1.1);
            background-color: #ffd700;
        }
        #willy-ad {
            width: 230px; /* 15% bigger than original 200px */
            height: auto;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        #willy-ad:hover {
            transform: scale(1.1);
        }
        #snicklink {
            color: #ffcc00;
            text-decoration: underline;
            font-size: 18px;
            cursor: pointer;
        }
        #snicklink:hover {
            color: #ffd700;
        }
        .music-credit {
            margin-top: 5px;
            font-size: 12px;
        }
        .music-credit a {
            color: #aaa;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        .music-credit a:hover {
            color: #fff;
            text-decoration: underline;
        }
        .support-message {
            font-size: 18px;
            color: #ffffff;
            margin: 5px 0 5px 0;
            text-align: center;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="start-container">
            <div id="start-products">
                <a href="https://snicklink.myshopify.com/collections/chemtrail-fighter" target="_blank" class="product-link">
                    <img src="./assets/hoodie.png" alt="Chemtrail Fighter Hoodie" class="product-image">
                </a>
                <img id="game-logo" src="./assets/gamelogo.png" alt="Game Logo">
                <a href="https://snicklink.myshopify.com/collections/chemtrail-fighter" target="_blank" class="product-link">
                    <img src="./assets/tasse.png" alt="Chemtrail Fighter Mug" class="product-image">
                </a>
            </div>
            <button id="start-btn">Start</button>
        </div>
    </div>
    <canvas id="game-canvas"></canvas>
    <div id="score">Score: 0</div>
    <button id="sound-toggle">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M2 7H5L9 3V17L5 13H2V7Z" fill="white"/>
            <path d="M12 7C13.1 7.67 14 9.23 14 10.5C14 11.77 13.1 13.33 12 14" stroke="white" stroke-width="2" stroke-linecap="round"/>
            <path d="M15 4C17.1 5.34 18.5 7.8 18.5 10.5C18.5 13.2 17.1 15.66 15 17" stroke="white" stroke-width="2" stroke-linecap="round"/>
        </svg>
    </button>
    <div id="upgrades">
        <button id="upgrade-size" class="upgrade-btn">Size</button>
        <button id="upgrade-style" class="upgrade-btn">Style</button>
        <button id="upgrade-shoot" class="upgrade-btn">???</button>
    </div>
    <input id="cheatcode" type="text" placeholder="CHEAT">
    <div id="game-over">
        <div id="game-over-container">
            <img id="game-over-logo" src="./assets/gamelogo.png" alt="Game Logo" style="width: 300px; margin-bottom: 20px;">
            <div id="game-over-text">
                <h1>GAME OVER</h1>
                <p class="points">Points: 0</p>
                <p class="message">Deutschland ist komplett verseucht<br>und DU allein bist Schuld!</p>
                <button id="play-again-btn">Play again</button>
            </div>
            <p class="support-message">Please support my work ❤️</p>
            <div id="bottom-products">
                <a href="https://snicklink.myshopify.com/collections/chemtrail-fighter" target="_blank" class="product-link">
                    <img src="./assets/hoodie.png" alt="Chemtrail Fighter Hoodie" class="product-image">
                </a>
                <a href="https://snicklink.de" target="_blank"><img id="willy-ad" src="./assets/willyad.png" alt="Willy Ad"></a>
                <a href="https://snicklink.myshopify.com/collections/chemtrail-fighter" target="_blank" class="product-link">
                    <img src="./assets/tasse.png" alt="Chemtrail Fighter Mug" class="product-image">
                </a>
            </div>
            <div class="music-credit">
                <a href="https://www.youtube.com/watch?v=VtKvzC7sS2I" target="_blank">Song by Jeff Saxon</a>
            </div>
        </div>
    </div>
    <audio id="background-music" loop preload="auto">
        <source src="./assets/wolken.mp3" type="audio/mp3">
    </audio>
    <audio id="schwurbler-music" preload="auto">
        <source src="./assets/schwurbler.mp3" type="audio/mp3">
    </audio>
    <audio id="twinkle-sound" preload="auto">
        <source src="./assets/twinkle.mp3" type="audio/mp3">
    </audio>
    <audio id="shot-sound" preload="auto">
        <source src="./assets/shot.mp3" type="audio/mp3">
    </audio>
    <audio id="explode-sound" preload="auto">
        <source src="./assets/explode.mp3" type="audio/mp3">
    </audio>
    <audio id="sky-music" preload="auto">
        <source src="./assets/sky.mp3" type="audio/mp3">
    </audio>
    <audio id="best-sound" preload="auto">
        <source src="./assets/best.mp3" type="audio/mp3">
    </audio>
    <audio id="star-sound" preload="auto">
        <source src="./assets/star.mp3" type="audio/mp3">
    </audio>
    <audio id="hover-sound" preload="auto">
        <source src="./assets/hover.mp3" type="audio/mp3">
    </audio>
    <audio id="click-sound" preload="auto">
        <source src="./assets/click.mp3" type="audio/mp3">
    </audio>
    <audio id="kill-sound" preload="auto">
        <source src="./assets/kill.mp3" type="audio/mp3">
    </audio>
    <audio id="kill2-sound" preload="auto">
        <source src="./assets/kill2.mp3" type="audio/mp3">
    </audio>
    <audio id="kill3-sound" preload="auto">
        <source src="./assets/kill3.mp3" type="audio/mp3">
    </audio>
    <audio id="kill4-sound" preload="auto">
        <source src="./assets/kill4.mp3" type="audio/mp3">
    </audio>
    <audio id="kill5-sound" preload="auto">
        <source src="./assets/kill5.mp3" type="audio/mp3">
    </audio>
    <audio id="kill6-sound" preload="auto">
        <source src="./assets/kill6.mp3" type="audio/mp3">
    </audio>
    <audio id="kill7-sound" preload="auto">
        <source src="./assets/kill7.mp3" type="audio/mp3">
    </audio>
    <audio id="life-sound" preload="auto">
        <source src="./assets/life.mp3" type="audio/mp3">
    </audio>
    <audio id="alarm-sound" preload="auto">
        <source src="./assets/alarm2.mp3" type="audio/mp3">
    </audio>
    <audio id="skull-sound" preload="auto">
        <source src="./assets/skull.mp3" type="audio/mp3">
    </audio>
    <audio id="own-music" preload="auto">
        <source src="./assets/own.mp3" type="audio/mp3">
    </audio>
    <audio id="message-sound" preload="auto">
        <source src="./assets/message.mp3" type="audio/mp3">
    </audio>
    <audio id="message2-sound" preload="auto">
        <source src="./assets/message2.mp3" type="audio/mp3">
    </audio>

    <script>
        /*********************************************
         * GAME CONFIGURATION - SPAWN PROBABILITIES
         *********************************************/
        console.log("Script starting...");
        
        // Add error handling to catch and log any JavaScript errors
        window.onerror = function(message, source, lineno, colno, error) {
            console.error("JavaScript Error:", message);
            console.error("Source:", source);
            console.error("Line:", lineno, "Column:", colno);
            console.error("Error object:", error);
            return false;
        };
        
        const CONFIG = {
            // Plane spawn probabilities (values between 0 and 1)
            PLANES: {
                NORMAL: 0.7,      // Regular planes
                RAINBOW: 0.10,    // Rainbow planes
                REPTO: 0.15,      // Repto planes
                NPC: 0.05,        // NPC planes
            },
            
            // Power-up spawn probabilities (values between 0 and 1)
            POWERUPS: {
                ONYX: 0.05,       // Onyx powerup
                STAR: 0.15,       // Star powerup
                SKULL: 0.20,      // Skull powerup (high probability for testing)
                COIN: 0.60        // Coin powerup
            },
            
            // Collectible spawn rates (in frames)
            SPAWN_RATES: {
                ONYX_FIRST_SPAWN: 1800,  // First onyx spawn (30 seconds at 60fps)
                ONYX_RANDOM_DELAY: 600,  // Random delay added to first spawn
                NORMAL_SPAWN_CHANCE: 0.003, // Chance per frame for normal spawns
            },
            
            // Sound configuration
            SOUND: {
                PROP_SOUNDS_MIN_MESSAGES: 3,  // Min messages before playing a prop sound
                PROP_SOUNDS_MAX_MESSAGES: 6,  // Max messages before playing a prop sound
            },
            
            // Performance configuration
            PERFORMANCE: {
                REMOVE_OFFSCREEN_TRAILS: true,  // Remove trails that are completely off-screen
                OFF_SCREEN_MARGIN: 50,         // Margin for off-screen detection (pixels)
                OPTIMIZE_PARTICLES: true,      // Optimize particle generation
                BATCH_RENDERING: true,         // Use batch rendering techniques
                SIMPLIFY_EFFECTS: true,        // Simplify visual effects for better performance
                TRAIL_SEGMENT_LENGTH: 5        // Length between trail segments (higher = fewer segments)
            }
        };
        
        // Log the configuration for easy reference
        console.log("=== GAME CONFIGURATION ===");
        console.log("PLANE SPAWN PROBABILITIES:", CONFIG.PLANES);
        console.log("POWERUP SPAWN PROBABILITIES:", CONFIG.POWERUPS);
        console.log("SPAWN RATES:", CONFIG.SPAWN_RATES);
        console.log("SOUND CONFIG:", CONFIG.SOUND);
        console.log("PERFORMANCE CONFIG:", CONFIG.PERFORMANCE);
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const scoreDisplay = document.getElementById('score');
        const music = document.getElementById('background-music');
        const schwurblerMusic = document.getElementById('schwurbler-music');
        const twinkleSound = document.getElementById('twinkle-sound');
        const shotSound = document.getElementById('shot-sound');
        const explodeSound = document.getElementById('explode-sound');
        const soundToggle = document.getElementById('sound-toggle');
        const skyMusic = document.getElementById('sky-music');
        const bestSound = document.getElementById('best-sound');
        const starSound = document.getElementById('star-sound');
        const hoverSound = document.getElementById('hover-sound');
        const clickSound = document.getElementById('click-sound');
        const killSound = new Audio('./assets/kill.mp3'); // Sound for first kill in star mode
        const kill2Sound = new Audio('./assets/kill2.mp3');
        const kill3Sound = new Audio('./assets/kill3.mp3');
        const kill4Sound = new Audio('./assets/kill4.mp3');
        const kill5Sound = new Audio('./assets/kill5.mp3');
        const kill6Sound = new Audio('./assets/kill6.mp3');
        const kill7Sound = new Audio('./assets/kill7.mp3');
        const lifeSound = new Audio('./assets/life.mp3'); // Special sound for 7 consecutive kills
        const alarmSound = new Audio('./assets/alarm2.mp3'); // Alarm sound for critical chemtrail density
        const ownMusic = new Audio('./assets/own.mp3');
        const messageSound = document.getElementById('message-sound'); // Sound for messages and bonus points
        const message2Sound = document.getElementById('message2-sound'); // Sound for upgrade messages
        const skullSound = new Audio('./assets/skull.mp3'); // Sound for Death Mode
        
        // Set default volume for alarm sound to 15% (much lower than before)
        alarmSound.volume = 0.15;
        
        // Current active mode music track
        let currentModeMusic = null;
        let currentMode = 'normal'; // Track the current music mode
        
        // Counter for message-based sound effects
        let messageCounter = 0;
        
        // Random number between 3-6 for when to play the next prop sound
        let nextPropSoundAt = Math.floor(Math.random() * 4) + 3; // 3-6 range
        
        // Function to play a random sound from the props folder
        function playRandomPropSound() {
            if (!soundEnabled) return;
            
            // Dynamically load all sound files from the props folder
            const propSounds = [
                'boom.mp3',
                'chemtastic.mp3',
                'chemtastic2.mp3',
                'foul.mp3',
                'say.mp3',
                'thats.mp3'
                // No need to manually update this list - we'll scan the directory dynamically
            ];
            
            // Choose a random sound
            const randomIndex = Math.floor(Math.random() * propSounds.length);
            const soundFile = propSounds[randomIndex];
            
            // Create and play the sound
            try {
                // Use a direct path to the sound file
                const propSound = new Audio(`./assets/props/${soundFile}`);
                propSound.volume = 0.7; // Set volume to 70%
                
                // Play the sound with proper error handling
                const playPromise = propSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(e => {
                        console.log(`Prop sound ${soundFile} failed to play:`, e);
                    });
                }
                
                console.log(`Playing random prop sound: ${soundFile} (${randomIndex + 1}/${propSounds.length})`);
                
                // Set the next trigger point using the configuration
                nextPropSoundAt = Math.floor(Math.random() * 
                    (CONFIG.SOUND.PROP_SOUNDS_MAX_MESSAGES - CONFIG.SOUND.PROP_SOUNDS_MIN_MESSAGES + 1)) + 
                    CONFIG.SOUND.PROP_SOUNDS_MIN_MESSAGES;
                    
                messageCounter = 0;
                
                console.log(`Next prop sound will play after ${nextPropSoundAt} messages`);
            } catch (e) {
                console.log(`Failed to play prop sound ${soundFile}:`, e);
            }
        }
        
        // Function to toggle mute state without restarting music
        function toggleMuteState() {
            if (!currentModeMusic) return;
            
            if (soundEnabled) {
                currentModeMusic.muted = false;
            } else {
                currentModeMusic.muted = true;
            }
        }
        
        // Comprehensive music management system
        function playModeMusic(mode) {
            // Update the current mode
            currentMode = mode;
            
            // Stop any currently playing mode music
            if (music && !music.paused) music.pause();
            if (schwurblerMusic && !schwurblerMusic.paused) schwurblerMusic.pause();
            if (starSound && !starSound.paused) starSound.pause();
            if (ownMusic && !ownMusic.paused) ownMusic.pause();
            if (skyMusic && !skyMusic.paused) skyMusic.pause();
            if (bestSound && !bestSound.paused) bestSound.pause();
            
            // Reset current music track
            currentModeMusic = null;
            
            // Play the appropriate music based on mode
            try {
                switch(mode) {
                    case 'normal':
                        music.currentTime = 0;
                        music.muted = !soundEnabled; // Ensure correct muted state
                        music.play();
                        currentModeMusic = music;
                        break;
                    case 'schwab':
                        ownMusic.currentTime = 0;
                        ownMusic.muted = !soundEnabled; // Ensure correct muted state
                        ownMusic.play();
                        currentModeMusic = ownMusic;
                        break;
                    case 'onyx':
                        schwurblerMusic.currentTime = 0;
                        schwurblerMusic.muted = !soundEnabled; // Ensure correct muted state
                        schwurblerMusic.play();
                        currentModeMusic = schwurblerMusic;
                        break;
                    case 'star':
                        starSound.currentTime = 0;
                        starSound.muted = !soundEnabled; // Ensure correct muted state
                        starSound.play();
                        currentModeMusic = starSound;
                        break;
                    case 'clean':
                        bestSound.currentTime = 0;
                        bestSound.muted = !soundEnabled; // Ensure correct muted state
                        bestSound.play();
                        currentModeMusic = bestSound;
                        break;
                    case 'gameover':
                        skyMusic.currentTime = 0;
                        skyMusic.muted = !soundEnabled; // Ensure correct muted state
                        skyMusic.play();
                        currentModeMusic = skyMusic;
                        break;
                    case 'death':
                        skullSound.currentTime = 0;
                        skullSound.muted = !soundEnabled;
                        skullSound.play();
                        currentModeMusic = skullSound;
                        break;
                    default:
                        // Default to normal music
                        music.currentTime = 0;
                        music.muted = !soundEnabled; // Ensure correct muted state
                        music.play();
                        currentModeMusic = music;
                }
                
                console.log(`Playing ${mode} mode music`);
            } catch (e) {
                console.error(`Failed to play ${mode} mode music:`, e);
            }
        }
        
        const upgradesDiv = document.getElementById('upgrades');
        
        const sizeBtn = document.getElementById('upgrade-size');
        const styleBtn = document.getElementById('upgrade-style');
        const shootBtn = document.getElementById('upgrade-shoot');
        const cheatcodeInput = document.getElementById('cheatcode');
        const gameOverDiv = document.getElementById('game-over');
        const gameOverText = document.getElementById('game-over-text');
        const playAgainBtn = document.getElementById('play-again-btn');
        const perfToggle = document.getElementById('perf-toggle');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Load images
        const planeImg = new Image();
        planeImg.src = './assets/plane.png';
        const planerImg = new Image();
        planerImg.src = './assets/planer.png';
        
        // Load NPC plane images
        const npcPlaneImg = new Image();
        npcPlaneImg.src = './assets/npcplane.png';
        npcPlaneImg.onerror = () => console.error("Failed to load npcplane.png");
        npcPlaneImg.onload = () => console.log("Successfully loaded npcplane.png");
        
        const npcPlanerImg = new Image();
        npcPlanerImg.src = './assets/npcplaner.png';
        npcPlanerImg.onerror = () => console.error("Failed to load npcplaner.png");
        npcPlanerImg.onload = () => console.log("Successfully loaded npcplaner.png");
        
        // Preload Schwab collectible image
        const schwabImg = new Image();
        schwabImg.src = './assets/schwab.png';
        
        // Preload Skull collectible image
        const skullImage = new Image();
        skullImage.src = './assets/skull.png';
        
        const cursorImgs = Array(6).fill().map((_, i) => {
            const img = new Image();
            // Use goldhat.png for the first style upgrade (styleLevel = 1)
            if (i === 1) {
                img.src = `./assets/goldhat.png`;
            } 
            // Use bratwurst.png for the second style upgrade (styleLevel = 2)
            else if (i === 2) {
                img.src = `./assets/bratwurst.png`;
            }
            // Use bademantel.png for the third style upgrade (styleLevel = 3)
            else if (i === 3) {
                img.src = `./assets/bademantel.png`;
            }
            // Use john.png for the fourth style upgrade (styleLevel = 4)
            else if (i === 4) {
                img.src = `./assets/john.png`;
            }
            // Use willy.png for the fifth style upgrade (styleLevel = 5)
            else if (i === 5) {
                img.src = `./assets/willy.png`;
            }
            // Use tinfoilhat.png for the default (styleLevel = 0)
            else {
                img.src = `./assets/tinfoilhat.png`;
            }
            return img;
        });
        const cloudImgs = [new Image(), new Image()];
        cloudImgs[0].src = './assets/cloud1.png';
        cloudImgs[1].src = './assets/cloud2.png';
        
        const explosionFrames = [];
        for (let i = 0; i <= 22; i++) {
            const img = new Image();
            img.src = `./assets/exp/frame-${String(i).padStart(6, '0')}.png`;
            explosionFrames.push(img);
        }

        let gameStarted = false;
        let gameOver = false;
        let forceCriticalDensity = false; // Flag for CRIT cheat code to force critical density warning
        let gameTime = 0;
        let lastSchwabSpawn = 0; // Track when we last spawned a Schwab collectible
        let score = 0;
        let totalScore = 0; // Track total points collected during the game
        let cheatPoints = 0; // Track points gained through cheatcodes
        let highScore = parseInt(localStorage.getItem('highScore')) || 0;
        let sizeLevel = 0;
        let prevSizeLevel = undefined; // Added for star power-up temporary size upgrade
        let styleLevel = 0;
        let shootLevel = 0;
        let starTimer = 0;
        let onyxTimer = 0;
        let onyxTextX = canvas.width;
        let isInverted = false;
        
        // Global color inversion function for Onyx Mode
        // This ensures all current and future game elements are properly inverted
        function invertColor(color) {
            if (!isInverted) return color;
            
            // Handle different color formats
            if (!color) return '#ffffff'; // Default to white if no color provided
            
            // Handle HSL colors
            if (color.startsWith('hsl')) {
                const hslMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    const h = (parseInt(hslMatch[1]) + 180) % 360; // Invert hue by adding 180 degrees
                    return `hsl(${h}, ${hslMatch[2]}%, ${hslMatch[3]}%)`;
                }
            }
            
            // Handle rgba colors
            if (color.startsWith('rgba')) {
                const rgbaMatch = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
                if (rgbaMatch) {
                    const r = 255 - parseInt(rgbaMatch[1]);
                    const g = 255 - parseInt(rgbaMatch[2]);
                    const b = 255 - parseInt(rgbaMatch[3]);
                    return `rgba(${r}, ${g}, ${b}, ${rgbaMatch[4]})`;
                }
            }
            
            // Handle rgb colors
            if (color.startsWith('rgb')) {
                const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = 255 - parseInt(rgbMatch[1]);
                    const g = 255 - parseInt(rgbMatch[2]);
                    const b = 255 - parseInt(rgbMatch[3]);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            
            // Handle hex colors
            if (color.startsWith('#')) {
                // Convert hex to RGB
                let r, g, b;
                if (color.length === 4) {
                    // Short hex format (#RGB)
                    r = parseInt(color[1] + color[1], 16);
                    g = parseInt(color[2] + color[2], 16);
                    b = parseInt(color[3] + color[3], 16);
                } else {
                    // Regular hex format (#RRGGBB)
                    r = parseInt(color.slice(1, 3), 16);
                    g = parseInt(color.slice(3, 5), 16);
                    b = parseInt(color.slice(5, 7), 16);
                }
                
                // Invert RGB values
                r = 255 - r;
                g = 255 - g;
                b = 255 - b;
                
                // Convert back to hex
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            // Return original color if format not recognized
            return color;
        }
        
        // Variables for cursor flashing effect during star power-up
        let cursorFlashing = false;
        let flashOpacity = 0;
        let flashDirection = -1;
        let mouseX = -100;
        let mouseY = -100;
        let targetMode = false;
        let targetPlane = null;
        let targetRemaining = false;
        let targetPosition = { x: 0, y: 0 };
        let shots = [];
        let shotCount = 0;
        let shotCooldown = 0;
        let isMouseDown = false;
        let chemtrails = [];
        let planes = [];
        let fallingPlanes = []; // Array to track planes falling in star mode
        let consecutiveStarKills = 0; // Counter for consecutive plane kills in star mode
        let particles = [];
        let collectibles = [];
        let twinkleEffects = [];
        let clouds = [];
        let cityFront = [];
        let cityMid = [];
        let cityFar = [];
        let explosions = [];
        let soundEnabled = true;
        let messages = [];
        let comboCount = 0;
        let lastPlaneExplodeTime = 0;
        let skyCleanMessageShown = false;
        let cleanSkyEventCount = 0; // Counter for clean sky events
        let lastCleanSkyEventTime = 0; // Track when the last clean sky event occurred
        let gameHasStarted = false;
        let schwabMode = false;
        // Add variable to track Schwab Mode duration
        let schwabModeTimer = 0;
        let schwabModeMaxTime = 3780; // 1 minute and 3 seconds (at 60fps)
        let sprayParticles = [];
        let hitIndicators = []; // Array for hit indicators
        let slowMode = false; // Track slow mode status for plane spawning
        // Add a variable to track Venom mode
        let venomMode = false;
        // Variable to store the last frame for game over screen
        let lastFrameImageData = null;
        let deathMode = false; // Flag for Death Mode
        let deathModeTimer = 0; // Timer for Death Mode
        let deathModeSpawnCount = 0; // Counter for planes spawned in Death Mode

        // Replace single upgrade costs array with separate arrays for each type
        // const upgradeCosts = [10000, 40000, 90000, 160000, 250000];
        const sizeUpgradeCosts = [100000, 250000, 1000000, 5000000, 10000000]; // Size upgrade costs
        const styleUpgradeCosts = [50000, 100000, 150000, 200000, 1000000]; // Style upgrade costs
        const shootUpgradeCosts = [250000, 1000000, 2500000, 5000000]; // Shoot upgrade costs - four levels: ???, Auto-Fire, One Shot, Venom
        
        const cursorSizes = [60, 90, 135, 202.5, 303.75, 455.625];
        const cursorColors = ['#fff', '#ff0', '#0ff', '#f0f', '#00f', '#f00'];
        const explosionSizeFactor = 1.1;

        // Global spray particle offset control 
        // This value determines how far away from the plane the spray particles appear
        // Positive values = further behind the plane
        // Negative values = closer to the plane
        // Change this value to adjust all spray particles at once
        let SPRAY_OFFSET = -0.8; // Very negative value moves particles much closer to the plane
        
        // Variable to track cheat code input
        let cheatsInput = "";

        // Plane spawn parameters
        const MIN_SPAWN_INTERVAL = 150; // Fastest spawn rate (frames between spawns)
        const MAX_SPAWN_INTERVAL = 450; // Slowest spawn rate (frames between spawns)
        const SPAWN_RAMP_UP_TIME = 60 * 60; // 60 seconds at 60fps = 3600 frames for full ramp-up
        let nextPlaneSpawn = 0; // Track when to spawn the next plane
        
        // Power-up spawn parameters
        const BASE_POWERUP_CHANCE = 0.003; // Base chance per frame
        const MIN_POWERUP_INTERVAL = 900; // Minimum frames between power-ups (15 seconds)
        let lastPowerupTime = 0; // Track last powerup spawn time

        // Special trail trackers
        let reptoTrailsExist = false;
        let rainbowTrailsExist = false;
        let reptoTrailsCount = 0;
        let rainbowTrailsCount = 0;
        let reptoTrailsCleared = false;
        let rainbowTrailsCleared = false;

        // Variables to track special trail planes and their bonuses
        let specialTrailPlanes = {}; // Object to track planes with special trails
        let specialTrailBonusesAwarded = {}; // Object to track which planes have had bonuses awarded
        let planeTrailSegments = {}; // Track segments for each plane
        let planeTrailsCleared = {}; // Track which planes have had all trails cleared
        let lastTrailBonusTime = 0; // Track when the last trail bonus was awarded

        // Plane Type Registry - Define plane types with their properties
        const PLANE_TYPES = {
            // Standard plane types
            NORMAL: {
                id: 'normal',
                name: 'Normal Plane',
                baseImage: 'plane', // Will use plane.png and planer.png
                probability: CONFIG.PLANES.NORMAL,
                sizeFactor: {min: 0.5, max: 1.0, giant: {chance: 0.05, size: 3}},
                lineWidth: (sizeFactor) => sizeFactor === 3 ? 9 : 3,
                points: (sizeFactor) => sizeFactor === 3 ? 50 : 10,
                opacity: {min: 0.25, max: 1.0},
                speed: {min: 1, max: 3},
                trailType: 'normal',
                trailMultiplier: 1,
                trailMessage: "TRAIL BUSTER", // Add default trail message for normal planes
                stealthFactor: 0
            },
            STEALTH: {
                id: 'stealth',
                name: 'Stealth Plane',
                baseImage: 'plane', // Will use plane.png and planer.png
                probability: 0.1, // 10% chance
                sizeFactor: {min: 0.2, max: 0.5},
                lineWidth: () => 1,
                points: () => 20,
                opacity: {min: 0.1, max: 0.3},
                speed: {min: 2, max: 5},
                trailType: 'normal',
                trailMultiplier: 1,
                stealthFactor: 1
            },
            // Special trail planes
            RAINBOW: {
                id: 'rainbow',
                name: 'Rainbow Trail Plane',
                baseImage: 'plane', // Will use plane.png and planer.png
                probability: CONFIG.PLANES.RAINBOW,
                sizeFactor: {min: 0.5, max: 1.0, giant: {chance: 0.05, size: 3}},
                lineWidth: (sizeFactor) => sizeFactor === 3 ? 9 : 3,
                points: (sizeFactor) => sizeFactor === 3 ? 50 : 10,
                opacity: {min: 0.25, max: 1.0},
                speed: {min: 1, max: 3},
                trailType: 'rainbow',
                trailMultiplier: 3,
                trailMessage: "INSTA-GAY TRAIL BONUS",
                stealthFactor: 0
            },
            REPTO: {
                id: 'repto',
                name: 'Repto Trail Plane',
                baseImage: 'plane', // Will use plane.png and planer.png
                probability: CONFIG.PLANES.REPTO,
                sizeFactor: {min: 0.5, max: 1.0, giant: {chance: 0.05, size: 3}},
                lineWidth: (sizeFactor) => sizeFactor === 3 ? 9 : 3,
                points: (sizeFactor) => sizeFactor === 3 ? 50 : 10,
                opacity: {min: 0.25, max: 1.0},
                speed: {min: 1, max: 3},
                trailType: 'repto',
                trailMultiplier: 2,
                trailMessage: "REPTO TRAIL BONUS",
                stealthFactor: 0
            },
            // NPC Plane - only spawned via cheat code, not naturally
            NPC: {
                id: 'npc',
                name: 'NPC Plane',
                baseImage: 'npcplane', // Will use npcplane.png and npcplaner.png
                probability: 0, // 0% chance - doesn't spawn naturally
                sizeFactor: {min: 0.6, max: 0.9}, // Slightly larger than normal planes
                lineWidth: () => 5, // Thicker trail
                points: () => 25, // Points for shooting down
                opacity: {min: 0.7, max: 1.0}, // More visible
                speed: {min: 1.5, max: 2.5}, // Average speed
                trailType: 'npc', // New trail type
                trailMultiplier: 1.5, // 50% bonus points
                trailMessage: "NPC ERROR BONUS!",
                stealthFactor: 0 // Not stealthy
            }
        };

        // Helper function to get a random plane type based on probabilities
        function getRandomPlaneType() {
            // First determine if it's a stealth plane
            if (Math.random() < PLANE_TYPES.STEALTH.probability) {
                return PLANE_TYPES.STEALTH;
            }
            
            // Check if it's an NPC plane
            if (Math.random() < CONFIG.PLANES.NPC) {
                return PLANE_TYPES.NPC;
            }
            
            // Otherwise use the configuration values for special trail planes
            const random = Math.random();
            const rainbowThreshold = CONFIG.PLANES.RAINBOW;
            const reptoThreshold = rainbowThreshold + CONFIG.PLANES.REPTO;
            
            if (random < rainbowThreshold) {
                return PLANE_TYPES.RAINBOW;
            } else if (random < reptoThreshold) {
                return PLANE_TYPES.REPTO;
            } else {
                return PLANE_TYPES.NORMAL;
            }
        }

        // Function to check if a special trail bonus should be awarded
        function checkSpecialTrailBonus() {
            // Get all unique plane IDs from chemtrails
            const planeIds = [...new Set(chemtrails.map(trail => trail.planeId))];
            
            // For each plane that has special trails
            Object.keys(specialTrailPlanes).forEach(planeId => {
                // Skip if bonus already awarded
                if (specialTrailBonusesAwarded[planeId]) {
                    return;
                }
                
                // Check if this plane has any trails left
                const hasTrails = planeIds.includes(planeId);
                
                // If no trails left, check if the plane is no longer active
                if (!hasTrails) {
                    const planeInfo = specialTrailPlanes[planeId];
                    
                    // Only award for repto or rainbow trails
                    if (planeInfo.trailType === 'repto' || planeInfo.trailType === 'rainbow') {
                        // Check if the plane is still active (still creating trails)
                        const planeStillActive = planes.some(p => p.id === planeId);
                        
                        // Only award bonus if the plane is no longer active
                        if (!planeStillActive) {
                            // Determine bonus amount and color
                            const msgColor = planeInfo.trailType === 'repto' ? '#39FF14' : '#ff00ff';
                            const bonusAmount = planeInfo.trailType === 'repto' ? 2000 : 3000;
                            
                            console.log("Awarding bonus for plane:", planeId, "Type:", planeInfo.trailType, "Amount:", bonusAmount);
                            
                            // Show bonus message
                            addCenterMessage(`${planeInfo.trailMessage}!`, msgColor, 40, 120);
                            addCenterMessage(`+${bonusAmount} POINTS`, '#ffff00', 30, 120);
                            
                            // Add bonus points
                            addPoints(bonusAmount);
                            totalScore += bonusAmount; // Update total score
                            scoreDisplay.textContent = `Score: ${score}`;
                            
                            // Mark bonus as awarded
                            specialTrailBonusesAwarded[planeId] = true;
                            planeTrailsCleared[planeId] = true;
                            
                            console.log(`Special trail bonus awarded for plane ${planeId}: ${planeInfo.trailType} - ${bonusAmount} points`);
                        }
                    }
                }
            });
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * (canvas.width + 200);
                this.y = Math.random() * canvas.height * 0.8;
                this.sizeFactor = Math.random() * 0.5 + 0.5;
                this.opacity = Math.random() * 0.5 + 0.2;
                this.speed = Math.random() * 0.4 + 0.2;
                this.type = Math.floor(Math.random() * 2);
            }
            update() {
                this.x -= this.speed;
                if (this.x + (190 * this.sizeFactor) < 0) {
                    this.x = canvas.width + Math.random() * 200;
                    this.y = Math.random() * canvas.height * 0.8;
                    this.sizeFactor = Math.random() * 0.5 + 0.5;
                    this.opacity = Math.random() * 0.5 + 0.2;
                    this.speed = Math.random() * 0.4 + 0.2;
                    this.type = Math.floor(Math.random() * 2);
                }
            }
            draw() {
                const img = cloudImgs[this.type];
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const width = 190 * this.sizeFactor;
                const height = 70 * this.sizeFactor;
                if (img.complete && img.naturalWidth) {
                    ctx.drawImage(img, this.x, this.y - height / 2, width, height);
                } else {
                    ctx.fillStyle = isInverted ? '#000' : '#fff';
                    ctx.fillRect(this.x, this.y - height / 2, width, height);
                }
                ctx.restore();
            }
        }

        class Plane {
            constructor(forceTrailType = null, forcePlaneType = null) {
                try {
                    // Use the plane type registry if a specific type is provided
                    let planeType;
                    
                    if (forcePlaneType) {
                        // Use the specified plane type
                        planeType = forcePlaneType;
                        console.log("Creating plane with forced type:", planeType.id);
                    } else if (forceTrailType) {
                        // If only trail type is forced, find the matching plane type
                        if (forceTrailType === 'rainbow') {
                            planeType = PLANE_TYPES.RAINBOW;
                        } else if (forceTrailType === 'repto') {
                            planeType = PLANE_TYPES.REPTO;
                        } else {
                            planeType = PLANE_TYPES.NORMAL;
                        }
                        console.log("Creating plane with forced trail type:", forceTrailType);
                    } else {
                        // Get a random plane type based on probabilities
                        planeType = getRandomPlaneType();
                        console.log("Creating random plane of type:", planeType.id);
                    }
                    
                    // Store the plane type for reference
                    this.planeTypeId = planeType.id;
                    
                    // Set base properties from the plane type
                    this.type = planeType.stealthFactor > 0 ? 'stealth' : 'normal';
                    
                    // Determine size factor based on plane type
                    if (planeType.sizeFactor.giant && Math.random() < planeType.sizeFactor.giant.chance) {
                        this.sizeFactor = planeType.sizeFactor.giant.size;
                    } else {
                        this.sizeFactor = planeType.sizeFactor.min + Math.random() * (planeType.sizeFactor.max - planeType.sizeFactor.min);
                    }
                    
                    // Set other properties based on plane type
                    this.lineWidth = planeType.lineWidth(this.sizeFactor);
                    this.points = planeType.points(this.sizeFactor);
                    this.opacity = planeType.opacity.min + Math.random() * (planeType.opacity.max - planeType.opacity.min);
                    this.tIncrement = planeType.stealthFactor > 0 ? 4 : 2;
                    
                    // Create a unique ID for tracking trail segments
                    this.id = 'plane_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // Set trail properties
                    this.trailType = planeType.trailType;
                    this.trailMultiplier = planeType.trailMultiplier || 1;
                    
                    // Register ALL planes in the specialTrailPlanes registry, not just those with a message
                    specialTrailPlanes[this.id] = {
                        trailType: this.trailType,
                        trailMessage: planeType.trailMessage || (this.trailType === 'normal' ? "TRAIL BUSTER" : 
                                      (this.trailType === 'npc' ? "NPC ERROR BONUS!" : ""))
                    };
                    console.log(`Plane added to registry: ${this.id}, Type: ${this.planeTypeId}, Trail type: ${this.trailType}`);
                    
                    // Also set the trailMessage property on the plane itself
                    this.trailMessage = specialTrailPlanes[this.id].trailMessage;
                    
                    this.isCurved = Math.random() < 0.1;
                    this.t = 0;
                    this.loopCount = this.isCurved ? Math.floor(Math.random() * 2) + 1 : 0;
                    this.initPath();
                    this.lastTrail = { x: this.x, y: this.y };
                    this.frame = 0; // For rainbow animation
                    
                    // Track trail segments from this plane
                    this.trailSegmentCount = 0;
                } catch (e) {
                    console.error("Error creating plane:", e);
                }
            }
            initPath() {
                try {
                    const speedFactor = this.type === 'stealth' ? Math.random() * 3 + 2 : Math.random() * 2 + 1;
                    if (this.isCurved) {
                        this.fromLeft = Math.random() < 0.5;
                        this.x = this.fromLeft ? -50 : canvas.width + 50;
                        this.y = Math.random() * canvas.height * 0.8;
                        this.startX = this.x;
                        this.startY = this.y;
                        this.targetX = this.fromLeft ? canvas.width + 50 : -50;
                        this.amplitude = canvas.height * 0.3;
                        this.frequency = this.loopCount * Math.PI * 2 / canvas.width;
                    } else {
                        const isHorizontal = Math.random() < 0.8;
                        if (isHorizontal) {
                            const fromLeft = Math.random() < 0.5;
                            this.x = fromLeft ? -50 : canvas.width + 50;
                            this.y = Math.random() < 0.9 ? Math.random() * (canvas.height * 0.66) : canvas.height * 0.66 + Math.random() * (canvas.height * 0.34);
                            const targetX = fromLeft ? canvas.width : 0;
                            const targetY = Math.random() * canvas.height;
                            const angle = Math.atan2(targetY - this.y, targetX - this.x);
                            this.dx = speedFactor * Math.cos(angle);
                            this.dy = speedFactor * Math.sin(angle);
                        } else {
                            const fromTop = Math.random() < 0.5;
                            this.x = Math.random() * canvas.width;
                            this.y = fromTop ? -50 : canvas.height + 50;
                            const targetY = fromTop ? canvas.height : 0;
                            const targetX = Math.random() * canvas.width;
                            const angle = Math.atan2(targetY - this.y, targetX - this.x);
                            this.dx = speedFactor * Math.cos(angle);
                            this.dy = speedFactor * Math.sin(angle);
                        }
                    }
                } catch (e) {
                    console.error("Error initializing plane path:", e);
                    // Set default values to prevent further errors
                    this.x = Math.random() * canvas.width;
                    this.y = -50;
                    this.dx = 0;
                    this.dy = 2;
                    this.isCurved = false;
                }
            }
            update() {
                if (this.isCurved) {
                    this.t += this.fromLeft ? this.tIncrement : -this.tIncrement;
                    const prevX = this.x;
                    const prevY = this.y;
                    this.x = this.startX + this.t;
                    this.y = this.startY + Math.sin(this.t * this.frequency) * this.amplitude;
                    this.dx = this.x - prevX;
                    this.dy = this.y - prevY;
                } else {
                    this.x += this.dx;
                    this.y += this.dy;
                }
                
                const angle = Math.atan2(this.dy, this.dx);
                const width = 75.3 * this.sizeFactor / 2;
                const height = 32.1 * this.sizeFactor / 2;
                
                const offsetX = -Math.cos(angle) * width * 0.9;
                // Make the Y offset scale with plane size by using a percentage of height instead of fixed +5 value
                const offsetY = -Math.sin(angle) * width * 0.9 + (height * 0.3); // 30% of height instead of fixed +5
                
                // Use the configured trail segment length for optimization
                const trailSegmentLength = CONFIG.PERFORMANCE.TRAIL_SEGMENT_LENGTH;
                
                // Only create new trail segments if we've moved far enough
                if (Math.hypot(this.x - this.lastTrail.x, this.y - this.lastTrail.y) > trailSegmentLength) {
                    // Create the trail segment
                    const newTrail = {
                        x1: this.lastTrail.x,
                        y1: this.lastTrail.y,
                        x2: this.x + offsetX,
                        y2: this.y + offsetY,
                        width: this.lineWidth,
                        color: this.trailColor,
                        points: this.points,
                        trailType: this.trailType,
                        trailMessage: this.trailMessage,
                        planeId: this.id,
                        planeActive: true,
                        trailMultiplier: this.trailMultiplier || 1,
                        creationTime: gameTime, // Add creation time for age-based optimization
                        id: 'trail_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9) // Add unique ID
                    };
                    
                    chemtrails.push(newTrail);
                    
                    // Increment trail segment count for bonus tracking
                    this.trailSegmentCount++;
                    
                    this.lastTrail = {
                        x: this.x + offsetX,
                        y: this.y + offsetY
                    };
                    
                    // Create spray particles for visual effect
                    const trailAngle = Math.atan2(offsetY, offsetX);
                    
                    // Create more particles based on plane size for a denser effect
                    const particleCount = Math.min(5, Math.max(2, Math.floor(this.lineWidth * 1.2))); // Increased count
                    
                    // Determine if the plane is flying right (dx > 0) or left (dx < 0)
                    const isFlyingRight = this.dx > 0;
                    
                    for (let i = 0; i < particleCount; i++) {
                        sprayParticles.push(new SprayParticle(
                            this.x + offsetX, 
                            this.y + offsetY, 
                            trailAngle, 
                            this.opacity * 0.8 + 0.2, // Slightly higher opacity for better visibility
                            this.lineWidth, // Pass the line width to scale particles appropriately
                            isFlyingRight, // This parameter is maintained for backward compatibility but no longer affects the angle
                            this.sizeFactor, // Pass the plane's size factor for consistent positioning
                            this.trailType // Pass trail type for spray particles
                        ));
                    }
                    
                    // Increment frame for rainbow animation
                    this.frame = (this.frame + 1) % 60;
                }
                
                if (this.x < -50 || this.x > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) {
                    // Mark all chemtrails from this plane as having an inactive plane
                    chemtrails.forEach(trail => {
                        if (trail.planeId === this.id) {
                            trail.planeActive = false;
                        }
                    });
                    
                    // Update the total segments count in planeTrailSegments to match the actual number created
                    if (planeTrailSegments[this.id]) {
                        planeTrailSegments[this.id].totalSegments = this.trailSegmentCount;
                        console.log(`Plane ${this.id} left screen. Total segments: ${this.trailSegmentCount}, Trail type: ${this.trailType}`);
                    }
                    
                    planes = planes.filter(p => p !== this);
                    if (this === targetPlane) {
                        targetPlane = null;
                        targetMode = false;
                        shotCount = 0;
                        shots = [];
                        shotCooldown = 0;
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.dy, this.dx));
                const width = 75.3 * this.sizeFactor;
                const height = 32.1 * this.sizeFactor;
                
                let img;
                let flipHorizontal = false;
                let flipVertical = false;
                
                if (schwabMode) {
                    // When in Schwab mode, use the Schwab image
                    img = schwabImg;
                    // Determine flip direction based on movement
                    flipHorizontal = this.isCurved ? !this.fromLeft : this.dx < 0;
                    flipVertical = this.isCurved ? !this.fromLeft : this.dx < 0;
                } else if (this.planeTypeId === 'npc') {
                    // Use NPC plane images for NPC planes
                    if (this.isCurved) {
                        img = this.fromLeft ? npcPlaneImg : npcPlanerImg;
                        flipHorizontal = !this.fromLeft;
                        flipVertical = !this.fromLeft;
                    } else {
                        img = this.dx > 0 ? npcPlaneImg : npcPlanerImg;
                        flipHorizontal = this.dx < 0;
                        flipVertical = this.dx < 0;
                    }
                } else if (this.isCurved) {
                    img = this.fromLeft ? planeImg : planerImg;
                    flipHorizontal = !this.fromLeft;
                    flipVertical = !this.fromLeft;
                } else {
                    img = this.dx > 0 ? planeImg : planerImg;
                    flipHorizontal = this.dx < 0;
                    flipVertical = this.dx < 0;
                }
                
                if (img && img.complete && img.naturalWidth) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    if (flipHorizontal || flipVertical) {
                        tempCtx.translate(flipHorizontal ? width : 0, flipVertical ? height : 0);
                        tempCtx.scale(flipHorizontal ? -1 : 1, flipVertical ? -1 : 1);
                    }
                    
                    tempCtx.drawImage(img, 0, 0, width, height);
                    
                    // Only apply black fill for regular planes, not for Schwab mode or NPC planes
                    if (!schwabMode && this.planeTypeId !== 'npc') {
                        tempCtx.globalCompositeOperation = 'source-in';
                        tempCtx.fillStyle = isInverted ? '#fff' : '#000'; // Invert color in onyx mode
                        tempCtx.fillRect(0, 0, width, height);
                    }
                    
                    ctx.drawImage(tempCanvas, -width / 2, -height / 2, width, height);
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = isInverted ? '#fff' : '#000'; // Invert color in onyx mode
                    ctx.fillRect(-width / 2, -height / 2, width, height);
                    
                    // Log error for debugging
                    console.error("Failed to load plane image:", this.planeTypeId, img);
                }
                
                ctx.restore();
            }
        }

        class Shot {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 10;
                const angle = Math.atan2(targetY - y, targetX - x);
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
                this.size = 5;
            }
            update() {
                this.x += this.dx;
                this.y += this.dy;
                if (targetPlane && Math.hypot(this.x - targetPlane.x, this.y - targetPlane.y) < 30) { // Increased hit radius from 20 to 30
                    // Only count the shot if this is the first projectile to hit in this volley
                    const isFirstHit = shots.indexOf(this) === 0;
                    if (isFirstHit) {
                        shotCount++;
                        console.log("Shot hit! Count:", shotCount);
                        
                        // Remove hit indicator creation - no longer needed
                        // hitIndicators.push(new HitIndicator(targetPlane.x, targetPlane.y, 25));
                    }
                    
                    shots = shots.filter(s => s !== this);
                    
                    // For level 3+ (One Shot), destroy the plane immediately with one hit
                    if (shootLevel >= 3) {
                        shotCount = 999; // Set to a high number to ensure it exceeds any required shots
                    }
                    
                    // Determine required shots based on plane size
                    let requiredShots = 5; // Default for small planes
                    
                    if (targetPlane.sizeFactor >= 2.5) { // Changed from exact match to >= for more reliability
                        requiredShots = 15; // Big planes (sizeFactor 2.5 or larger)
                        console.log("Big plane detected. Required shots:", requiredShots);
                    } else if (targetPlane.sizeFactor >= 0.5) {
                        requiredShots = 10; // Medium planes
                        console.log("Medium plane detected. Required shots:", requiredShots);
                    }
                    
                    console.log(`Current shots: ${shotCount}/${requiredShots}`);
                    
                    if (shotCount >= requiredShots) {
                        console.log("ENOUGH SHOTS! Destroying plane now!");
                        // Store the position of the exploding target
                        targetPosition.x = targetPlane.x;
                        targetPosition.y = targetPlane.y;
                        
                        // Set flag to keep target cursor visible during explosion
                        targetRemaining = true;
                        
                        // Mark all chemtrails from this plane as having an inactive plane
                        chemtrails.forEach(trail => {
                            if (trail.planeId === targetPlane.id) {
                                trail.planeActive = false;
                            }
                        });
                        
                        // Only create falling plane effect in star mode
                        // In normal mode, just create an explosion
                        if (starTimer > 0) {
                            fallingPlanes.push(new FallingPlane(targetPlane));
                        }
                        
                        explosions.push(new Explosion(targetPlane.x, targetPlane.y, targetPlane.sizeFactor));
                        if (soundEnabled) {
                            try { explodeSound.play(); } catch (e) { console.log("Explode sound failed:", e); }
                        }
                        
                        // Add score based on plane type and size
                        const planeScore = targetPlane.points * 100;
                        addPoints(planeScore);
                        updateScoreDisplay();
                        
                        // Create a twinkle effect to show the score
                        twinkleEffects.push(new Twinkle(targetPlane.x, targetPlane.y, `+${planeScore}`));
                        
                        // Handle combo system
                        const currentTime = gameTime;
                        const timeSinceLast = currentTime - lastPlaneExplodeTime;
                        console.log("Plane destroyed! Combo count:", comboCount);
                        
                        // Always increment combo count regardless of time passed
                        comboCount++;
                        console.log("Combo incremented to:", comboCount);
                        if (comboCount >= 5) {
                            console.log("Combo 5 achieved!");
                            const comboBonus = 5000;
                            addPoints(comboBonus);
                            updateScoreDisplay();
                            
                            // Force a new center message for combo with more visibility
                            const comboMsg = new CenterMessage(`NICE COMBO! +${comboBonus}`, '#ffffff', 40, 180);
                            messages = messages.filter(m => !(m instanceof CenterMessage && m.text.includes("COMBO"))); // Remove any existing combo messages
                            messages.push(comboMsg);
                            console.log("Added combo message to messages array. Current messages:", messages.length);
                            
                            // Force immediate display of the message
                            comboMsg.draw();
                            
                            comboCount = 0; // Reset after awarding bonus
                        }
                        
                        lastPlaneExplodeTime = currentTime; // Keep tracking time for debugging purposes
                        
                        // Remove the plane but keep targeting mode active until explosion ends
                        planes = planes.filter(p => p !== targetPlane);
                        console.log("Plane destroyed! Remaining planes:", planes.length, "Combo:", comboCount);
                        targetPlane = null;
                        shots = [];
                        shotCount = 0;
                        shotCooldown = 0;
                    }
                }
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    shots = shots.filter(s => s !== this);
                }
            }
            draw() {
                ctx.save();
                ctx.fillStyle = isInverted ? '#000' : '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Explosion {
            constructor(x, y, sizeFactor = 1) {
                this.x = x;
                this.y = y;
                this.frame = 0;
                this.maxFrames = explosionFrames.length;
                this.life = this.maxFrames * 2;
                this.size = 100 * explosionSizeFactor * sizeFactor;
                this.isLastExplosion = true;
            }
            update() {
                this.life--;
                this.frame = Math.floor((this.maxFrames - 1) * (1 - this.life / (this.maxFrames * 2)));
                if (this.frame >= this.maxFrames) this.frame = this.maxFrames - 1;
                
                if (this.life <= 0 && this.isLastExplosion && targetRemaining) {
                    targetRemaining = false;
                    targetMode = false;
                }
            }
            draw() {
                const img = explosionFrames[this.frame];
                if (img.complete && img.naturalWidth) {
                    ctx.save();
                    if (isInverted) ctx.filter = 'invert(1)';
                    ctx.translate(this.x, this.y);
                    ctx.drawImage(img, -this.size / 2, -this.size / 2, this.size, this.size);
                    ctx.restore();
                }
            }
        }

        // FallingPlane class for star mode plane destruction effect
        class FallingPlane {
            constructor(plane) {
                // Copy position and appearance from original plane
                this.x = plane.x;
                this.y = plane.y;
                this.sizeFactor = plane.sizeFactor;
                
                // Copy all special image properties
                this.isSchwab = schwabMode; // Use global schwabMode flag
                this.planeTypeId = plane.planeTypeId; // Store the plane type ID to identify NPC planes
                this.type = plane.type;
                this.isCurved = plane.isCurved;
                this.fromLeft = plane.fromLeft;
                this.dx = plane.dx > 0 ? 1 : -1; // Direction for image flipping
                
                // Initialize falling motion properties
                this.fallingSpeed = 1.5;  // Initial falling speed
                this.acceleration = 0.2;  // Gravity acceleration effect
                this.rotation = 0;        // Current rotation angle
                this.rotationSpeed = (Math.random() * 0.2) - 0.1; // Random rotation (left or right)
                this.swingOffset = 0;      // Side-to-side movement offset
                this.swingSpeed = (Math.random() * 0.8) + 0.2; // Speed of side-to-side swing
                this.swingDirection = Math.random() > 0.5 ? 1 : -1; // Random initial swing direction
                this.swingAmount = Math.random() * 6; // Maximum amount of side-to-side swing
                
                // Track lifespan
                this.life = 120; // Frames before disappearing
            }
            
            update() {
                // Update vertical position with acceleration
                this.fallingSpeed += this.acceleration;
                this.y += this.fallingSpeed;
                
                // Update rotation
                this.rotation += this.rotationSpeed;
                
                // Update side-to-side swing motion (pendulum effect)
                this.swingOffset = Math.sin(this.swingSpeed * (this.life / 10)) * this.swingAmount * this.swingDirection;
                this.x += this.swingOffset / 5; // Apply a portion of the swing each frame
                
                // Reduce life counter
                this.life--;
                
                // Return true if still active, false if it should be removed
                return this.life > 0 && this.y < canvas.height + 100;
            }
            
            draw() {
                // Calculate image dimensions
                const width = 75.3 * this.sizeFactor;
                const height = 32.1 * this.sizeFactor;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation); // Apply rotation
                
                // Choose the correct image based on direction and type
                let img;
                let flipHorizontal = false;
                let flipVertical = false;
                
                if (this.isSchwab) {
                    // When in Schwab mode, use the Schwab image
                    img = schwabImg;
                    // Determine flip direction based on movement
                    flipHorizontal = this.isCurved ? !this.fromLeft : this.dx < 0;
                    flipVertical = this.isCurved ? !this.fromLeft : this.dx < 0;
                } else if (this.planeTypeId === 'npc') {
                    // Use NPC plane images for NPC planes
                    if (this.isCurved) {
                        img = this.fromLeft ? npcPlaneImg : npcPlanerImg;
                        flipHorizontal = !this.fromLeft;
                        flipVertical = !this.fromLeft;
                    } else {
                        img = this.dx > 0 ? npcPlaneImg : npcPlanerImg;
                        flipHorizontal = this.dx < 0;
                        flipVertical = this.dx < 0;
                    }
                } else if (this.isCurved) {
                    img = this.fromLeft ? planeImg : planerImg;
                    flipHorizontal = !this.fromLeft;
                    flipVertical = !this.fromLeft;
                } else {
                    img = this.dx > 0 ? planeImg : planerImg;
                    flipHorizontal = this.dx < 0;
                    flipVertical = this.dx < 0;
                }
                
                if (img.complete && img.naturalWidth) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    if (flipHorizontal || flipVertical) {
                        tempCtx.translate(flipHorizontal ? width : 0, flipVertical ? height : 0);
                        tempCtx.scale(flipHorizontal ? -1 : 1, flipVertical ? -1 : 1);
                    }
                    
                    tempCtx.drawImage(img, 0, 0, width, height);
                    
                    // Only apply black fill for regular planes, not for Schwab mode or NPC planes
                    if (!this.isSchwab && this.planeTypeId !== 'npc') {
                        tempCtx.globalCompositeOperation = 'source-in';
                        tempCtx.fillStyle = invertColor('#000'); // Use invertColor function
                        tempCtx.fillRect(0, 0, width, height);
                    }
                    
                    // Apply invert filter in onyx mode for Schwab image
                    if (isInverted && this.isSchwab) {
                        ctx.filter = 'invert(100%)';
                    }
                    
                    ctx.drawImage(tempCanvas, -width / 2, -height / 2, width, height);
                } else {
                    ctx.fillStyle = invertColor('#000'); // Use invertColor function
                    ctx.fillRect(-width / 2, -height / 2, width, height);
                }
                
                ctx.restore();
            }
        }

        class PowerUp {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.size = 20;
                this.dx = (Math.random() - 0.5) * 2;
                this.dy = (Math.random() - 0.5) * 2;
                this.angle = 0;
                this.particles = [];
            }
            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.angle += 0.1;
                if (Math.random() < 0.05 && this.particles.length < 5) {
                    this.particles.push({ x: 0, y: 0, size: Math.random() * 5 + 2, life: 15 });
                }
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life--;
                    p.size = Math.max(0, p.size - 0.2);
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    collectibles = collectibles.filter(c => c !== this);
                }
            }
            drawParticles() {
                ctx.save();
                ctx.translate(this.x, this.y);
                this.particles.forEach(p => {
                    if (p.size > 0) {
                        // Use invertColor function for particle colors
                        const particleColor = `rgba(255, 255, ${this.type === 'star' ? 0 : 255}, ${p.life / 15})`;
                        ctx.fillStyle = invertColor(particleColor);
                        ctx.beginPath();
                        ctx.arc(p.x + (Math.random() - 0.5) * 10, p.y + (Math.random() - 0.5) * 10, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.restore();
            }
        }

        class CoinPowerUp extends PowerUp {
            constructor(x, y) { 
                super('coin', x, y);
                
                // Animation properties
                this.frameCount = 22; // Total number of frames (0-21)
                this.currentFrame = 0;
                this.animationSpeed = 0.5; // Frames to advance per game frame
                this.frameCounter = 0;
                
                // Preload all coin animation frames
                this.frames = [];
                for (let i = 0; i < this.frameCount; i++) {
                    const frameNumber = i.toString().padStart(6, '0');
                    const img = new Image();
                    img.src = `./assets/coin/frame-${frameNumber}.png`;
                    this.frames.push(img);
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Get the current frame image
                const frameImg = this.frames[Math.floor(this.currentFrame)];
                
                // Draw the current frame centered on the coin's position
                if (frameImg.complete) {
                    // Calculate the position to center the image
                    const drawWidth = this.size * 1.5;
                    const drawHeight = this.size * 1.5;
                    
                    // Apply invert filter in onyx mode
                    if (isInverted) {
                        ctx.filter = 'invert(1)';
                    }
                    
                    ctx.drawImage(frameImg, -drawWidth/2, -drawHeight/2, drawWidth, drawHeight);
                    
                    // Reset filter
                    if (isInverted) {
                        ctx.filter = 'none';
                    }
                } else {
                    // Fallback if image isn't loaded yet
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    // Use invertColor function instead of direct color inversion
                    ctx.fillStyle = invertColor('#ffd700');
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Update animation frame for next draw
                this.frameCounter += this.animationSpeed;
                if (this.frameCounter >= 1) {
                    this.currentFrame = (this.currentFrame + this.frameCounter) % this.frameCount;
                    this.frameCounter = this.frameCounter % 1;
                }
                
                // Draw the particles
                this.drawParticles();
            }
        }

        class StarPowerUp extends PowerUp {
            constructor(x, y) { super('star', x, y); }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                // Use invertColor function instead of direct color inversion
                ctx.fillStyle = invertColor('#00ffff');
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                    const outerX = Math.cos(angle) * this.size / 2;
                    const outerY = Math.sin(angle) * this.size / 2;
                    const innerX = Math.cos(angle + 2 * Math.PI / 5) * this.size / 4;
                    const innerY = Math.sin(angle + 2 * Math.PI / 5) * this.size / 4;
                    if (i === 0) ctx.moveTo(outerX, outerY);
                    else ctx.lineTo(outerX, outerY);
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                this.drawParticles();
            }
        }

        class OnyxPowerUp extends PowerUp {
            constructor(x, y) { 
                super('onyx', x, y); 
                this.sparkles = [];
                // Create more sparkles for a more magical effect
                for (let i = 0; i < 8; i++) {
                    this.sparkles.push({
                        angle: Math.random() * Math.PI * 2,
                        // Keep distance within the diamond shape
                        distance: Math.random() * (this.size / 3),
                        size: Math.random() * 1.5 + 0.5,
                        speed: Math.random() * 0.08 + 0.03,
                        // Add alpha for twinkling effect
                        alpha: Math.random() * 0.7 + 0.3,
                        // Add alpha change direction and speed
                        alphaChange: (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.03 + 0.01)
                    });
                }
            }
            
            draw() {
                const pulse = Math.sin(gameTime * 0.1) * 2 + this.size / 2;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Draw diamond first
                // Use invertColor function instead of direct color inversion
                ctx.fillStyle = invertColor('#000');
                ctx.beginPath();
                ctx.moveTo(0, -pulse);
                ctx.lineTo(pulse / 1.5, 0);
                ctx.lineTo(0, pulse);
                ctx.lineTo(-pulse / 1.5, 0);
                ctx.closePath();
                ctx.fill();
                
                // Add a subtle glow effect
                // Use invertColor function for glow effect
                ctx.strokeStyle = invertColor('rgba(100, 100, 255, 0.5)');
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw sparkles inside the diamond
                for (let sparkle of this.sparkles) {
                    // Update sparkle properties
                    sparkle.angle += sparkle.speed;
                    sparkle.alpha += sparkle.alphaChange;
                    
                    // Reverse alpha change direction at boundaries
                    if (sparkle.alpha > 1 || sparkle.alpha < 0.2) {
                        sparkle.alphaChange *= -1;
                        sparkle.alpha = Math.max(0.2, Math.min(1, sparkle.alpha));
                    }
                    
                    const sparkleX = Math.cos(sparkle.angle) * sparkle.distance;
                    const sparkleY = Math.sin(sparkle.angle) * sparkle.distance;
                    
                    // Create a gradient for each sparkle for a more magical effect
                    const gradient = ctx.createRadialGradient(
                        sparkleX, sparkleY, 0,
                        sparkleX, sparkleY, sparkle.size * 2
                    );
                    
                    // Use different colors based on invert mode with invertColor function
                    const sparkleBaseColor = `rgba(200, 200, 255, ${sparkle.alpha})`;
                    const sparkleTransparentColor = 'rgba(200, 200, 255, 0)';
                    
                    gradient.addColorStop(0, invertColor(sparkleBaseColor));
                    gradient.addColorStop(1, invertColor(sparkleTransparentColor));
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                this.drawParticles();
            }
        }

        class SchwabCollectible extends PowerUp {
            constructor(x, y) { super('schwab', x, y); }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Use the preloaded Schwab image
                if (schwabImg.complete && schwabImg.naturalWidth) {
                    // Draw the Schwab image
                    const size = this.size * 1.2; // Make it slightly larger
                    ctx.drawImage(schwabImg, -size / 2, -size / 2, size, size);
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = invertColor('#ff00ff');
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                this.drawParticles();
            }
        }

        class SkullCollectible extends PowerUp {
            constructor(x, y) {
                super('skull', x, y);
                this.sparkleTimer = 0;
                this.sparkles = [];
                
                // Create initial sparkles
                for (let i = 0; i < 5; i++) {
                    this.sparkles.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: Math.random() * (this.size / 2),
                        size: Math.random() * 1.5 + 0.5,
                        speed: Math.random() * 0.05 + 0.02,
                        alpha: Math.random() * 0.7 + 0.3,
                        alphaChange: (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.03 + 0.01)
                    });
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Draw skull image
                if (skullImage && skullImage.complete && skullImage.naturalWidth) {
                    const size = this.size * 1.2;
                    
                    // Apply invert filter in onyx mode
                    if (isInverted) {
                        ctx.filter = 'invert(100%)';
                    }
                    
                    ctx.drawImage(skullImage, -size / 2, -size / 2, size, size);
                    
                    // Reset filter
                    if (isInverted) {
                        ctx.filter = 'none';
                    }
                    
                    // Draw sparkles around the skull
                    for (let sparkle of this.sparkles) {
                        // Update sparkle properties
                        sparkle.angle += sparkle.speed;
                        sparkle.alpha += sparkle.alphaChange;
                        
                        // Reverse alpha change direction at boundaries
                        if (sparkle.alpha > 1 || sparkle.alpha < 0.2) {
                            sparkle.alphaChange *= -1;
                            sparkle.alpha = Math.max(0.2, Math.min(1, sparkle.alpha));
                        }
                        
                        const sparkleX = Math.cos(sparkle.angle) * sparkle.distance;
                        const sparkleY = Math.sin(sparkle.angle) * sparkle.distance;
                        
                        // Draw sparkle with invertColor
                        const sparkleColor = `rgba(255, 255, 255, ${sparkle.alpha})`;
                        ctx.fillStyle = invertColor(sparkleColor);
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = invertColor('#ff00ff');
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
                this.drawParticles();
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 1;
                // Reduce initial velocity to make particles less magnetic-looking
                this.dx = (Math.random() - 0.5) * 1.2;
                this.dy = (Math.random() - 0.5) * 1.2;
                this.life = 20;
                this.maxLife = 20;
                this.color = Math.random() > 0.7 ? '#ffffff' : '#f0f0f0'; // Slight color variation
                this.rotation = Math.random() * Math.PI * 2; // Random rotation
                this.rotationSpeed = (Math.random() - 0.5) * 0.2; // Random rotation speed
            }
            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.life--;
                
                // Reduce gravity effect
                this.dy += 0.02;
                
                // Add slight drag to slow particles down
                this.dx *= 0.98;
                this.dy *= 0.98;
                
                // Update rotation
                this.rotation += this.rotationSpeed;
                
                // Shrink as life decreases
                this.size = Math.max(0.5, this.size * 0.97);
            }
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = invertColor(`rgba(255, 255, 255, ${alpha})`);
                
                // Draw a slightly more interesting particle shape
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // 30% chance of drawing a square particle instead of a circle
                if (this.color === '#ffffff') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw a small square
                    const halfSize = this.size * 0.8;
                    ctx.fillRect(-halfSize, -halfSize, halfSize * 2, halfSize * 2);
                }
                
                ctx.restore();
            }
        }

        class SprayParticle {
            constructor(x, y, angle, opacity = 0.5, lineWidth = 2, isFlying_right = true, sizeFactor = 1, trailType = 'normal') {
                // Get the direction vector from the angle (direction of the trail)
                const dirX = Math.cos(angle);
                const dirY = Math.sin(angle);
                
                // Calculate a consistent plane-size-relative offset
                // This ensures all planes (small or large) have their spray at the same relative position
                // Use the plane's size factor to scale the base position
                const planeLength = 75.3 * sizeFactor; // Same calculation used for plane width
                
                // Base offset is now a percentage of the plane's length
                // This makes the position consistent across all plane sizes
                const baseOffsetPercentage = 0.05; // 5% of plane length (reduced from 15% to bring particles closer)
                const baseOffset = planeLength * baseOffsetPercentage;
                
                // Apply the global offset control
                // Positive SPRAY_OFFSET moves particles further away (trailing behind)
                // Negative SPRAY_OFFSET moves particles closer to the plane
                const adjustedOffset = baseOffset + (SPRAY_OFFSET * planeLength * 0.1);
                
                // Add a small random variation for natural appearance
                const randomVariation = Math.random() * (planeLength * 0.05);
                const offsetMagnitude = adjustedOffset + randomVariation;
                
                // Apply offset without directional multiplier to ensure identical offset distances
                // for both left-flying and right-flying planes
                this.x = x + dirX * offsetMagnitude;
                this.y = y + dirY * offsetMagnitude;
                
                // Add perpendicular spread for more natural appearance
                // Scale perpendicular spread to plane size as well
                const perpX = -dirY; // Perpendicular to direction
                const perpY = dirX;
                const perpScale = planeLength * 0.02; // 2% of plane length for perpendicular spread (reduced from 4%)
                const perpOffset = (Math.random() - 0.5) * perpScale;
                // Perpendicular offset isn't affected by direction
                this.x += perpX * perpOffset;
                this.y += perpY * perpOffset;
                
                // UPDATED FIX: Use the original angle with no modification
                // This will make particles flow in the same direction as the plane movement
                const particleAngle = angle;
                
                // Add randomness to the angle for natural dispersion
                const spreadAngleVariation = (Math.random() - 0.5) * 0.8;
                const spreadAngle = particleAngle + spreadAngleVariation;
                
                // More varied speeds for natural particle behavior
                // Scale speed based on plane size for consistent visual effect
                const baseSpeed = 1.5 + Math.random() * 2.5;
                const speed = baseSpeed * (sizeFactor * 0.5 + 0.5); // Scale with plane size but don't make too extreme
                
                // Calculate movement vector in the same direction as the plane
                this.dx = Math.cos(spreadAngle) * speed;
                this.dy = Math.sin(spreadAngle) * speed;
                
                // Slightly bigger particles for better visibility when behind the plane
                // Scale particle size relative to plane size but within a reasonable range
                const sizeScale = 0.5 + Math.random() * 0.3; // 50-80% of line width
                this.size = Math.max(2.0, lineWidth * sizeScale);
                
                // Slightly longer lifespan for better visibility
                // Scale lifespan with plane size for consistent trail length
                const lifespanScale = 0.8 + (sizeFactor * 0.2); // Larger planes get slightly longer trails
                this.maxLife = (12 + Math.random() * 8) * lifespanScale;
                this.life = this.maxLife;
                
                // Increased opacity for better visibility when behind the plane
                this.opacity = opacity * 1.2;
                
                // Add drift for natural movement matching particle direction
                this.drift = (Math.random() - 0.5) * 0.3 * sizeFactor;
                
                // Add trail type
                this.trailType = trailType;
            }
            
            update() {
                this.x += this.dx;
                this.y += this.dy;
                // Add slight drift to x movement for more natural flow
                this.x += this.drift;
                this.life--;
                
                // More gradual size reduction
                this.size = Math.max(0.2, this.size * 0.96);
            }
            
            draw() {
                // Higher opacity at the beginning for better visibility behind plane
                const fadeInFactor = this.life > this.maxLife * 0.8 ? 1.2 : 1.0;
                const alpha = (this.life / this.maxLife) * this.opacity * fadeInFactor;
                
                // Set color based on trail type
                let color;
                if (this.trailType === 'repto') {
                    color = `rgba(57, 255, 20, ${alpha})`; // Neon green
                } else if (this.trailType === 'rainbow') {
                    // Rainbow color cycling
                    const hue = (gameTime * 5 + this.x % 360) % 360;
                    color = `hsla(${hue}, 100%, 60%, ${alpha})`;
                } else if (this.trailType === 'npc') {
                    // NPC plane trail - middle grey
                    color = `rgba(128, 128, 128, ${alpha})`;
                } else {
                    // Default white or black based on inversion
                    color = isInverted ? 
                        `rgba(0, 0, 0, ${alpha})` : 
                        `rgba(255, 255, 255, ${alpha})`;
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Twinkle {
            constructor(x, y, text) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.life = 30;
                this.size = 10;
            }
            update() {
                this.life--;
                this.size += 1;
            }
            draw() {
                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life / 30})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
                if (this.text) {
                    ctx.font = '16px Arial';
                    ctx.fillStyle = `rgba(255, 255, 0, ${this.life / 30})`;
                    ctx.fillText(this.text, this.x + 10, this.y - 10);
                }
                ctx.restore();
            }
        }

        class ShootFlash {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 10;
                this.size = 40;
            }
            update() {
                this.life--;
                this.size += 5;
            }
            draw() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.life / 10})`);
                gradient.addColorStop(0.3, `rgba(255, 255, 220, ${this.life / 12})`);
                gradient.addColorStop(0.6, `rgba(255, 250, 180, ${this.life / 15})`);
                gradient.addColorStop(1, 'rgba(255, 230, 100, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Message {
            constructor(text, x, y, color = '#fff', size = 16, duration = 60) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.color = invertColor(color); // Apply color inversion if in Onyx Mode
                this.size = size;
                this.life = duration;
                this.maxLife = duration;
                this.dy = -1; // Move upward
            }
            
            update() {
                this.life--;
                this.y += this.dy;
            }
            
            draw() {
                ctx.save();
                ctx.font = `bold ${this.size}px Arial`;
                ctx.fillStyle = invertColor(`rgba(0, 0, 0, 0.7)`); // Invert shadow color in Onyx Mode
                ctx.fillText(this.text, this.x + 2, this.y + 2);
                ctx.fillStyle = `rgba(${this.color.replace('#', '').match(/../g).map(h => parseInt(h, 16)).join(', ')}, ${this.life / this.maxLife})`;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        // Message class for displaying center screen messages
        class CenterMessage extends Message {
            constructor(text, color = '#ffffff', size = 30, duration = 120) { // Reduced duration from 180 to 120
                // Convert text to uppercase for retro style
                super(text.toUpperCase(), 0, 0, color, size, duration);
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.originalSize = size; // Use the provided size parameter
                this.scale = 1.0; // Start at full size to avoid scaling animation
                this.maxScale = 1.0; // Keep scale consistent
                this.scaleDirection = 0; // No scaling animation
                this.colorCycle = 0; // For color cycling effect
                
                // Track creation time for ordering
                this.creationTime = Date.now();
                
                // Increment message counter and check if we should play a prop sound
                messageCounter++;
                if (messageCounter >= nextPropSoundAt) {
                    playRandomPropSound();
                }
                
                if (soundEnabled) {
                    // Determine which sound to play based on message type
                    let soundToPlay = null;
                    
                    // Check if this is a star mode multiplier message
                    const isStarMultiplier = text.startsWith('+') && color === getStarModeMultiplierColor(consecutiveStarKills);
                    
                    // Check if this is an upgrade message (size, style, shooting)
                    const isUpgradeMessage = 
                        text.includes('SIZE') || 
                        text.includes('STYLE') || 
                        text.includes('SHOOTING') ||
                        text.includes('UPGRADED');
                        
                    // Check if this is a points message (starts with + but not a star multiplier)
                    const isPointsMessage = text.startsWith('+') && !isStarMultiplier;
                    
                    // Select the appropriate sound
                    if (isUpgradeMessage) {
                        soundToPlay = message2Sound;
                    } else if (isPointsMessage || (!isStarMultiplier && !isUpgradeMessage)) {
                        soundToPlay = messageSound;
                    }
                    
                    // Play the selected sound if any
                    if (soundToPlay) {
                        try {
                            soundToPlay.currentTime = 0; // Reset sound to beginning
                            soundToPlay.play().catch(e => console.log("Message sound failed to play:", e));
                        } catch (e) {
                            console.log("Message sound failed to play:", e);
                        }
                    }
                }
                
                // Add a debug log to confirm message creation
                console.log("Created center message:", text, "- Will display at", this.x, this.y);
            }
            
            update() {
                this.life--;
                // Remove color cycling and scaling animation to keep consistent appearance
            }
            
            draw() {
                console.log("Drawing:", this.text); // Debug log for message drawing
                
                ctx.save();
                ctx.translate(this.x, this.y);
                // Remove scaling to keep consistent size
                
                // Text with pixel font effect
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Use Visitor font with fallbacks
                ctx.font = `bold ${this.originalSize}px "Visitor", "Press Start 2P", monospace`;
                
                // Faster fade out - use a steeper curve for opacity
                const opacity = Math.min(1, this.life / (this.maxLife * 0.3)); // Even faster fade out
                
                // Use the provided color instead of rainbow effect for consistency
                // Convert hex color to RGB for opacity support
                const r = parseInt(this.color.slice(1, 3), 16);
                const g = parseInt(this.color.slice(3, 5), 16);
                const b = parseInt(this.color.slice(5, 7), 16);
                
                // 3D effect with pixel-like steps
                for (let i = 3; i > 0; i--) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * opacity})`;
                    ctx.fillText(this.text, i, i); // Shadow offset
                }
                
                // Main text with the message's color
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                ctx.fillText(this.text, 0, 0);
                
                ctx.restore();
            }
        }
        
        // HitIndicator class for visual feedback when shots hit planes
        class HitIndicator {
            constructor(x, y, size = 20) {
                this.x = x;
                this.y = y;
                this.life = 20;
                this.size = size;
                this.color = '#ffff00';
            }
            
            update() {
                this.life--;
            }
            
            draw() {
                const alpha = this.life / 20;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x - this.size/2, this.y);
                ctx.lineTo(this.x + this.size/2, this.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.size/2);
                ctx.lineTo(this.x, this.y + this.size/2);
                ctx.stroke();
                ctx.restore();
            }
        }

        function generateCityscape() {
            const buildingCount = Math.ceil(canvas.width / 100) + 5;
            cityFront = Array(buildingCount).fill().map((_, i) => ({
                x: i * 100,
                width: Math.random() * 80 + 20,
                height: Math.random() * 100 + 50
            }));
            cityMid = Array(buildingCount).fill().map((_, i) => ({
                x: i * 120,
                width: Math.random() * 100 + 30,
                height: Math.random() * 80 + 30
            }));
            cityFar = Array(buildingCount).fill().map((_, i) => ({
                x: i * 150,
                width: Math.random() * 120 + 40,
                height: Math.random() * 60 + 20
            }));
            
            console.log("Cityscape generated:", 
                        "Front buildings:", cityFront.length, 
                        "Mid buildings:", cityMid.length, 
                        "Far buildings:", cityFar.length);
        }

        // Initialize clouds
        clouds = Array(8).fill().map(() => new Cloud());
        
        // Generate the cityscape
        generateCityscape();

        // Create variables to track trail segments by plane
        // planeTrailSegments already declared above
        // planeTrailsCleared already declared above
        
        function startGame() {
            console.log("Starting game...");
            startScreen.style.opacity = '0';
            setTimeout(() => startScreen.style.display = 'none', 500);
            canvas.classList.add('active');
            // Remove any blur effect from previous game over
            canvas.style.filter = 'none';
            scoreDisplay.style.display = 'block';
            upgradesDiv.style.display = 'flex';
            cheatcodeInput.style.display = 'block';
            soundToggle.style.display = 'flex';
            gameOverDiv.style.display = 'none';

            // Remove the frozen canvas if it exists
            const frozenCanvas = document.getElementById('frozen-game-canvas');
            if (frozenCanvas) {
                console.log("Removing frozen game canvas");
                frozenCanvas.parentNode.removeChild(frozenCanvas);
            }

            // Reset all game variables
            gameStarted = true;
            gameOver = false;
            gameTime = 0;
            score = 0;
            totalScore = 0; // Track total points collected during the game
            cheatPoints = 0; // Track points gained through cheatcodes
            sizeLevel = 0;
            styleLevel = 0;
            shootLevel = 0;
            starTimer = 0;
            onyxTimer = 0;
            venomMode = false; // Reset venom mode
            onyxTextX = canvas.width;
            isInverted = false;
            mouseX = -100;
            mouseY = -100;
            targetMode = false;
            targetPlane = null;
            targetRemaining = false;
            targetPosition = { x: 0, y: 0 };
            shots = [];
            shotCount = 0;
            shotCooldown = 0;
            isMouseDown = false;
            chemtrails = [];
            planes = [];
            if (Math.random() > 0.5) planes.push(new Plane());
            particles = [];
            collectibles = [];
            twinkleEffects = [];
            explosions = [];
            messages = [];
            comboCount = 0;
            lastPlaneExplodeTime = 0;
            skyCleanMessageShown = false; // Make sure this is reset when starting a new game
            cleanSkyEventCount = 0; // Counter for clean sky events
            lastCleanSkyEventTime = 0; // Track when the last clean sky event occurred
            gameHasStarted = false;
            schwabMode = false;
            // Add variable to track Schwab Mode duration
            schwabModeTimer = 0;
            schwabModeMaxTime = 3780; // 1 minute and 3 seconds (at 60fps)
            sprayParticles = [];
            hitIndicators = [];
            
            // Reset cheat code input
            cheatsInput = '';
            cheatcodeInput.value = '';
            cheatcodeInput.placeholder = 'CHEAT';
            
            soundEnabled = true;
            slowMode = false; // Reset slow mode when starting a new game
            nextPlaneSpawn = 0; // Reset plane spawn timer
            lastPowerupTime = 0; // Reset powerup spawn timer

            // Reset special trail tracking
            specialTrailPlanes = {};
            specialTrailBonusesAwarded = {};
            
            // Reset trail counters
            reptoTrailsExist = false;
            rainbowTrailsExist = false;
            reptoTrailsCount = 0;
            rainbowTrailsCount = 0;
            reptoTrailsCleared = false;
            rainbowTrailsCleared = false;
            
            // Reset plane trail segments
            planeTrailSegments = {};
            planeTrailsCleared = {};
            lastTrailBonusTime = 0; // Reset trail bonus timer

            // Set initial sound button state
            soundToggle.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 7H5L9 3V17L5 13H2V7Z" fill="white"/>
                    <path d="M12 7C13.1 7.67 14 9.23 14 10.5C14 11.77 13.1 13.33 12 14" stroke="white" stroke-width="2" stroke-linecap="round"/>
                    <path d="M15 4C17.1 5.34 18.5 7.8 18.5 10.5C18.5 13.2 17.1 15.66 15 17" stroke="white" stroke-width="2" stroke-linecap="round"/>
                </svg>
            `;

            try {
                // Reset and restart music properly using the music management system
                // Stop any currently playing music
                if (music && !music.paused) music.pause();
                if (schwurblerMusic && !schwurblerMusic.paused) schwurblerMusic.pause();
                if (starSound && !starSound.paused) starSound.pause();
                if (ownMusic && !ownMusic.paused) ownMusic.pause();
                if (skyMusic && !skyMusic.paused) skyMusic.pause();
                if (bestSound && !bestSound.paused) bestSound.pause();
                
                // Reset all music tracks
                music.currentTime = 0;
                schwurblerMusic.currentTime = 0;
                skyMusic.currentTime = 0;
                starSound.currentTime = 0;
                ownMusic.currentTime = 0;
                bestSound.currentTime = 0;
                
                // Initialize all audio elements with the correct muted state
                music.muted = !soundEnabled;
                schwurblerMusic.muted = !soundEnabled;
                skyMusic.muted = !soundEnabled;
                starSound.muted = !soundEnabled;
                ownMusic.muted = !soundEnabled;
                bestSound.muted = !soundEnabled;
                twinkleSound.muted = !soundEnabled;
                
                updateScoreDisplay();
                if (soundEnabled) {
                    playModeMusic('normal');
                    twinkleSound.play();
                }
            } catch (e) {
                console.error("Error during game start:", e);
            }
        }

        startBtn.addEventListener('click', startGame);
        playAgainBtn.addEventListener('click', () => {
            // Stop any currently playing music when starting a new game
            if (currentModeMusic && !currentModeMusic.paused) {
                currentModeMusic.pause();
                currentModeMusic.currentTime = 0;
            }
            startGame();
        });
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            
            // Update the SVG color based on sound state
            const paths = soundToggle.querySelectorAll('path');
            paths.forEach(path => {
                path.setAttribute('fill', soundEnabled ? 'white' : '#666');
            });
            
            if (soundEnabled) {
                if (gameStarted && !gameOver) {
                    // If we already have active music, just unmute it
                    if (currentModeMusic) {
                        toggleMuteState();
                    } else {
                        // Otherwise play the appropriate music for the current mode
                        if (schwabMode) {
                            playModeMusic('schwab');
                        } else if (onyxTimer > 0) {
                            playModeMusic('onyx');
                        } else if (starTimer > 0) {
                            playModeMusic('star');
                        } else {
                            playModeMusic('normal');
                        }
                    }
                }
            } else {
                // Don't stop music, just mute it
                toggleMuteState();
            }
        });

        canvas.addEventListener('mousemove', e => { 
            mouseX = e.offsetX; 
            mouseY = e.offsetY; 
            if (shootLevel > 0 && gameStarted && !gameOver) {
                targetMode = false;
                targetPlane = null;
                for (let i = planes.length - 1; i >= 0; i--) {
                    const plane = planes[i];
                    const width = 75.3 * plane.sizeFactor;
                    const height = 32.1 * plane.sizeFactor;
                    const targetWidth = width * 1.4;
                    const targetHeight = height * 1.4;
                    if (mouseX >= plane.x - targetWidth / 2 && mouseX <= plane.x + targetWidth / 2 &&
                        mouseY >= plane.y - targetHeight / 2 && mouseY <= plane.y + targetHeight / 2) {
                        targetMode = true;
                        targetPlane = plane;
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mousedown', e => {
            isMouseDown = true;
            
            // Handle all shooting directly here - this is simpler and more reliable
            if (gameStarted && !gameOver) {
                // Only show flash effect and play sound when in target mode with shooting upgrade
                if (shootLevel >= 1 && targetMode && targetPlane) {
                    // Add a localized flash effect at the cursor position
                    particles.push(new ShootFlash(mouseX, mouseY));
                    
                    if (shotCooldown <= 0) {
                        // Create shots for all upgraded levels on initial click
                        const offset = 10;
                        shots.push(new Shot(mouseX + offset, mouseY, targetPlane.x, targetPlane.y));
                        shots.push(new Shot(mouseX - offset, mouseY, targetPlane.x, targetPlane.y));
                        
                        // Faster cooldown for level 2+ (auto-fire)
                        if (shootLevel >= 2) {
                            shotCooldown = 4; // Slightly slower fire rate for auto-fire (increased from 2)
                        } else {
                            shotCooldown = 6; // Normal cooldown for level 1
                        }
                        
                        // Play shot sound
                        if (soundEnabled) {
                            try {
                                const shotSoundClone = new Audio('./assets/shot.mp3');
                                shotSoundClone.volume = 0.5; // Slightly lower volume for machine gun effect
                                shotSoundClone.play();
                            } catch (e) {
                                console.log("Shot sound failed:", e);
                                try {
                                    shotSound.currentTime = 0;
                                    shotSound.play();
                                } catch (e2) {
                                    console.log("Fallback shot sound failed:", e2);
                                }
                            }
                        }
                        
                        // For level 3+ (One Shot), instantly destroy the target plane
                        if (shootLevel >= 3) {
                            destroyTargetPlane();
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // Add mouseenter event to update cursor position when mouse re-enters canvas
        canvas.addEventListener('mouseenter', e => { 
            mouseX = e.offsetX; 
            mouseY = e.offsetY; 
        });

        function fireShot() {
            // Basic requirement for all shooting: game must be started and not over
            if (!gameStarted || gameOver) return;
            
            // Ensure we have a valid target
            if (!targetMode || !targetPlane || shotCooldown > 0) return;
            
            try {
                const offset = 10;
                shots.push(new Shot(mouseX + offset, mouseY, targetPlane.x, targetPlane.y));
                shots.push(new Shot(mouseX - offset, mouseY, targetPlane.x, targetPlane.y));
                
                // Faster cooldown for level 2+ (auto-fire)
                if (shootLevel >= 2) {
                    shotCooldown = 4; // Slightly slower fire rate for auto-fire (increased from 2)
                } else {
                    shotCooldown = 6; // Normal cooldown for level 1
                }
                
                // Add a localized flash effect at the cursor position
                particles.push(new ShootFlash(mouseX, mouseY));
                
                // Play shot sound - more efficient implementation for rapid firing
                if (soundEnabled) {
                    try {
                        // Create a fresh audio instance for each shot to allow overlapping sounds
                        const shotSoundClone = new Audio('./assets/shot.mp3');
                        shotSoundClone.volume = 0.5; // Slightly lower volume for machine gun effect
                        shotSoundClone.play();
                    } catch (e) {
                        console.log("Shot sound failed:", e);
                    }
                }
                
                // For level 3 (One Shot) and level 4 (Venom) shoot upgrade, instantly destroy the target plane
                if (shootLevel >= 3) {
                    console.log("One-shot kill fired at level " + shootLevel);
                    
                    // Store the position of the exploding target
                    targetPosition.x = targetPlane.x;
                    targetPosition.y = targetPlane.y;
                    
                    // Set flag to keep target cursor visible during explosion
                    targetRemaining = true;
                    
                    // Mark all chemtrails from this plane as having an inactive plane
                    chemtrails.forEach(trail => {
                        if (trail.planeId === targetPlane.id) {
                            trail.planeActive = false;
                        }
                    });
                    
                    // Only create falling plane effect in star mode
                    if (starTimer > 0) {
                        fallingPlanes.push(new FallingPlane(targetPlane));
                    }
                    
                    explosions.push(new Explosion(targetPlane.x, targetPlane.y, targetPlane.sizeFactor));
                    if (soundEnabled) {
                        try { explodeSound.play(); } catch (e) { console.log("Explode sound failed:", e); }
                    }
                    
                    // Add score based on plane type and size
                    const planeScore = targetPlane.points * 100;
                    addPoints(planeScore);
                    updateScoreDisplay();
                    
                    // Add a message for the points scored
                    messages.push(new Message(`+${planeScore}`, targetPlane.x, targetPlane.y, '#ffffff', 24, 60)); // Increased size from 16 to 24 (1.5x bigger)
                    updateMessagePositions();
                    
                    // Find the plane in the array and remove it
                    const planeIndex = planes.findIndex(p => p.id === targetPlane.id);
                    if (planeIndex !== -1) {
                        planes.splice(planeIndex, 1);
                    }
                    
                    // Reset target after destroying plane
                    targetMode = false;
                    targetPlane = null;
                }
            } catch (e) {
                console.error("Error in fireShot:", e);
            }
        }

        sizeBtn.addEventListener('click', () => {
            if (sizeLevel < sizeUpgradeCosts.length && score >= sizeUpgradeCosts[sizeLevel]) {
                score -= sizeUpgradeCosts[sizeLevel];
                sizeLevel++;
                updateUpgrades();
                updateScoreDisplay();
                
                // Add message for upgrade
                messages.push(new CenterMessage(`Size Upgraded!`, '#fed430', 35, 150));
                updateCenterMessagePositions();
                
                // Trigger the upgrade animation
                upgradeAnimations.size = { 
                    time: 60, 
                    progress: 0, 
                    level: sizeLevel,
                    cost: sizeUpgradeCosts[sizeLevel] || 'MAX'
                };
            }
        });
        styleBtn.addEventListener('click', () => {
            if (styleLevel < styleUpgradeCosts.length && score >= styleUpgradeCosts[styleLevel]) {
                score -= styleUpgradeCosts[styleLevel];
                styleLevel++;
                updateUpgrades();
                updateScoreDisplay();
                
                // Add message for upgrade
                messages.push(new CenterMessage(`Style Upgraded!`, '#fd491e', 35, 150));
                updateCenterMessagePositions();
                
                // Trigger the upgrade animation
                upgradeAnimations.style = { 
                    time: 60, 
                    progress: 0,
                    level: styleLevel,
                    cost: styleUpgradeCosts[styleLevel] || 'MAX'
                };
            }
        });
        shootBtn.addEventListener('click', () => {
            if (shootLevel === 0 && score >= shootUpgradeCosts[0]) {
                score -= shootUpgradeCosts[0];
                shootLevel = 1;
                updateUpgrades();
                updateScoreDisplay();
                
                // Add message for upgrade
                messages.push(new CenterMessage(`??? Unlocked!`, '#4d0e7e', 35, 150));
                updateCenterMessagePositions();
                
                // Trigger the upgrade animation
                upgradeAnimations.shoot = { 
                    time: 60, 
                    progress: 0,
                    level: shootLevel
                };
            } else if (shootLevel === 1 && score >= shootUpgradeCosts[1]) {
                score -= shootUpgradeCosts[1];
                shootLevel = 2;
                updateUpgrades();
                updateScoreDisplay();
                
                // Add message for upgrade
                messages.push(new CenterMessage(`AUTO-FIRE UNLOCKED!`, '#ff9800', 40, 180));
                updateCenterMessagePositions();
                
                // Trigger the upgrade animation
                upgradeAnimations.shoot = { 
                    time: 60, 
                    progress: 0,
                    level: shootLevel
                };
            } else if (shootLevel === 2 && score >= shootUpgradeCosts[2]) {
                score -= shootUpgradeCosts[2];
                shootLevel = 3;
                updateUpgrades();
                updateScoreDisplay();
                
                // Add message for upgrade
                messages.push(new CenterMessage(`ONE SHOT UNLOCKED!`, '#ff0000', 40, 180));
                updateCenterMessagePositions();
                
                // Trigger the upgrade animation
                upgradeAnimations.shoot = { 
                    time: 60, 
                    progress: 0,
                    level: shootLevel
                };
            } else if (shootLevel === 3 && score >= shootUpgradeCosts[3]) {
                score -= shootUpgradeCosts[3];
                shootLevel = 4;
                // Enable Venom mode
                venomMode = true;
                updateUpgrades();
                updateScoreDisplay();
                
                // Add message for upgrade
                messages.push(new CenterMessage(`VENOM UNLOCKED!`, '#00ff00', 40, 180));
                updateCenterMessagePositions();
                
                // Trigger the upgrade animation
                upgradeAnimations.shoot = { 
                    time: 60, 
                    progress: 0,
                    level: shootLevel
                };
            }
        });

        // Prevent default input behavior and handle cheat codes
        cheatcodeInput.addEventListener('input', (e) => {
            // Prevent the default input behavior to avoid double letters
            e.preventDefault();
            
            // Clear the input field - we'll manage the value manually
            cheatcodeInput.value = cheatsInput;
            
            // Check for the END cheat code to immediately trigger game over
            if (gameStarted && cheatsInput.toUpperCase().includes('END')) {
                forceGameOver("Cheat code activated: END");
                
                // Reset cheat input
                cheatsInput = "";
                cheatcodeInput.value = "";
            }
            
            return false;
        });

        // Handle all cheat code input through the input field's keydown event
        cheatcodeInput.addEventListener('keydown', (e) => {
            // Prevent default to avoid double input
            e.preventDefault();
            
            // Only register on initial keypress
            if (e.repeat) return;
            
            // Handle backspace to remove last character
            if (e.key === 'Backspace') {
                if (cheatsInput.length > 0) {
                    cheatsInput = cheatsInput.substring(0, cheatsInput.length - 1);
                    cheatcodeInput.value = cheatsInput;
                    
                    // If input is now empty, reset placeholder
                    if (cheatsInput.length === 0) {
                        cheatcodeInput.value = '';
                    }
                }
                return;
            }
            
            // Ignore non-printable keys (except backspace which is handled above)
            if (e.key.length !== 1) {
                return;
            }
            
            // Auto-capitalize all input for cheat codes
            cheatsInput += e.key.toUpperCase();
            
            // Update the cheatcode input field to show current input
            cheatcodeInput.value = cheatsInput;
            
            // Process cheat codes - removed the gameOver condition to allow END to work
            if (!gameStarted) return;
            
            // Process cheat codes
            if (cheatsInput.includes("SLOW")) {
                slowMode = !slowMode;
                const msg = slowMode ? 
                    "SLOW MODE ACTIVATED" :
                    "SLOW MODE DEACTIVATED";
                messages.push(new CenterMessage(msg, '#00aaff', 35, 180));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }
            
            // Spray particle position adjustment commands (now using uppercase)
            // SPRAY+n: Move spray particles further away from plane
            // SPRAY-n: Move spray particles closer to plane
            // Where n is a number 1-9 indicating the adjustment strength
            if (cheatsInput.includes("SPRAY+") || cheatsInput.includes("SPRAY-")) {
                const isPlus = cheatsInput.includes("SPRAY+");
                const lastChar = cheatsInput.charAt(cheatsInput.length - 1);
                const adjustment = parseInt(lastChar);
                
                if (!isNaN(adjustment) && adjustment >= 1 && adjustment <= 9) {
                    // Calculate adjustment amount (0.1 to 0.9)
                    const amount = adjustment / 10;
                    if (isPlus) {
                        SPRAY_OFFSET += amount;
                    } else {
                        SPRAY_OFFSET -= amount;
                    }
                    
                    // Keep offset within reasonable bounds
                    SPRAY_OFFSET = Math.max(-1, Math.min(1, SPRAY_OFFSET));
                    
                    // Show feedback message
                    const direction = isPlus ? "further from" : "closer to";
                    messages.push(new CenterMessage(`SPRAY ${direction.toUpperCase()} PLANE`, '#00ff88', 25, 120));
                    console.log(`Spray offset adjusted to: ${SPRAY_OFFSET.toFixed(2)}`);
                    cheatsInput = ""; // Reset input after command
                    cheatcodeInput.value = ""; // Also clear the input field
                }
            }
            
            // Limit the cheat input buffer length to prevent it growing too large
            if (cheatsInput.length > 20) {
                cheatsInput = cheatsInput.substring(cheatsInput.length - 20);
                cheatcodeInput.value = cheatsInput; // Update the input field with the trimmed value
            }
            
            // Check for "star" cheat code to spawn a star powerup
            if (cheatsInput.includes("STAR")) {
                // Spawn a star powerup at a random position
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                collectibles.push(new StarPowerUp(x, y));
                messages.push(new CenterMessage("STAR POWERUP SPAWNED", '#ffff00', 30, 120));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }

            // Check for "schwab" cheat code to toggle Schwab mode
            if (cheatsInput.includes("SCHWAB")) {
                // Spawn a Schwab collectible at a random position
                const x = Math.random() * canvas.width * 0.8 + canvas.width * 0.1; // Keep away from edges
                const y = Math.random() * canvas.height * 0.6 + canvas.height * 0.1; // Keep in upper part of screen
                collectibles.push(new SchwabCollectible(x, y));
                messages.push(new CenterMessage("SCHWAB COLLECTIBLE SPAWNED", '#ff00ff', 30, 120));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }

            // Check for "sound" cheat code to toggle sound
            if (cheatsInput.includes("SOUND")) {
                soundEnabled = !soundEnabled;
                const msg = soundEnabled ? 
                    "SOUND ENABLED" :
                    "SOUND DISABLED";
                messages.push(new CenterMessage(msg, '#00ffff', 35, 120));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }

            // Check for "onyx" cheat code to activate onyx mode
            if (cheatsInput.includes("ONYX")) {
                if (!isInverted) {
                    onyxTimer = 840;
                    isInverted = true;
                    onyxTextX = canvas.width;
                    try { 
                        music.pause(); 
                        schwurblerMusic.play(); 
                    } catch (e) { console.log("Onyx audio failed:", e); }
                    messages.push(new CenterMessage("ONYX MODE ACTIVATED", '#ffffff', 35, 180));
                } else {
                    messages.push(new CenterMessage("ALREADY IN ONYX MODE", '#ffffff', 35, 120));
                }
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }
            
            // Check for "REPTO" cheat code to spawn a repto plane
            if (cheatsInput.includes("REPTO")) {
                // Create a new plane with repto trail
                const reptoPlane = new Plane('repto');
                console.log("REPTO plane created with ID:", reptoPlane.id, "and trail type:", reptoPlane.trailType);
                planes.push(reptoPlane);
                messages.push(new CenterMessage("REPTO PLANE SPAWNED", '#39FF14', 30, 120));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }
            
            // Check for "BUNT" cheat code to spawn a rainbow plane
            if (cheatsInput.includes("BUNT")) {
                // Create a new plane with rainbow trail
                const rainbowPlane = new Plane('rainbow');
                console.log("RAINBOW plane created with ID:", rainbowPlane.id, "and trail type:", rainbowPlane.trailType);
                planes.push(rainbowPlane);
                messages.push(new CenterMessage("RAINBOW PLANE SPAWNED", '#ff00ff', 30, 120));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }

            // Check for "reich" cheat code for bonus points
            if (cheatsInput.includes("REICH")) {
                addPoints(1000000);
                updateScoreDisplay();
                cheatPoints += 1000000; // Track these points as cheat points
                totalScore += 1000000; // Still add to total score for display during gameplay
                messages.push(new CenterMessage("+1,000,000 POINTS", '#ffff00', 35, 180));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }
            
            // Check for "0000" cheat code for unlimited points
            if (cheatsInput.includes("0000")) {
                // Give a massive amount of points (effectively unlimited)
                addPoints(999999999);
                updateScoreDisplay();
                cheatPoints += 999999999; // Track these points as cheat points
                totalScore += 999999999; // Still add to total score for display during gameplay
                messages.push(new CenterMessage("UNLIMITED POINTS ACTIVATED", '#ff0000', 40, 180));
                messages.push(new CenterMessage("YOU ARE NOW RICH BEYOND MEASURE", '#ffff00', 30, 180));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }
            
            // Check for "CRIT" cheat code to trigger critical chemtrail density warning
            if (cheatsInput.includes("CRIT")) {
                // Set a flag to force critical density warning
                forceCriticalDensity = true;
                
                // Play alarm sound at 15% volume
                if (soundEnabled) {
                    try {
                        alarmSound.volume = 0.15; // Set volume to 15%
                        alarmSound.currentTime = 0; // Reset to beginning
                        alarmSound.loop = true;
                        alarmSound.play().catch(e => console.log("Alarm sound failed to play:", e));
                    } catch (e) {
                        console.log("Alarm sound failed to play:", e);
                    }
                }
                
                messages.push(new CenterMessage("CRITICAL DENSITY WARNING ACTIVATED", '#ff0000', 30, 180));
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }

            // Check for "END" cheat code to end the game
            if (cheatsInput.includes("END")) {
                forceGameOver("Cheat code activated: END");
                
                cheatsInput = ""; // Reset input after finding a cheat
                cheatcodeInput.value = ""; // Also clear the input field
            }
            
            // Check for "CLEAN" cheat code to remove all planes and chemtrails
            if (cheatsInput.includes("CLEAN")) {
                // Remove all planes and chemtrails
                planes = [];
                chemtrails = [];
                
                // Clear any explosions, particles, and shots
                explosions = [];
                particles = [];
                shots = [];
                sprayParticles = [];
                
                console.log("Removed all planes and chemtrails");
                
                // Show clean sky message
                messages = messages.filter(m => !(m instanceof CenterMessage && m.text.includes("SKY"))); // Remove any existing sky messages
                addCenterMessage("THE SKY IS CLEAN!", '#ffffff', 50, 240);
                console.log("Added clean sky message and removed all planes/trails");
                
                // Set the flag to prevent duplicate messages
                skyCleanMessageShown = true;
                
                // Add bonus points for clean sky
                const cleanSkyBonus = 5000; // Match the regular sky clean bonus
                addPoints(cleanSkyBonus);
                updateScoreDisplay();
                
                // Add another message for the bonus points
                messages.push(new CenterMessage(`+${cleanSkyBonus} POINTS`, '#ffff00', 35, 180));
                
                // Play the clean sky music
                if (soundEnabled) {
                    playModeMusic('clean');
                }
                
                // Reset cheat input
                cheatsInput = "";
                cheatcodeInput.value = "";
            }
            
            // Add a TEST cheat code to manually trigger bonus messages
            if (cheatsInput.includes("TEST")) {
                console.log("TEST cheat code activated - testing bonus messages");
                
                // Test REPTO bonus message
                addCenterMessage("REPTO TRAIL BONUS!", '#39FF14', 40, 120);
                addCenterMessage("+2000 POINTS", '#ffff00', 30, 120);
                
                // After a short delay, test RAINBOW bonus message
                setTimeout(() => {
                    addCenterMessage("INSTA-GAY TRAIL BONUS!", '#ff00ff', 40, 120);
                    addCenterMessage("+3000 POINTS", '#ffff00', 30, 120);
                    console.log("Delayed rainbow bonus message triggered");
                }, 2000);
                
                // Add some points for visual feedback
                addPoints(5000);
                updateScoreDisplay();
                
                cheatsInput = "";
                cheatcodeInput.value = "";
            }

            // Add a DEBUG cheat code to show the current state of special trail planes and chemtrails
            if (cheatsInput.includes("DEBUG")) {
                console.log("DEBUG cheat code activated - showing special trail planes and chemtrails");
                
                // Log special trail planes
                console.log("Special Trail Planes:", specialTrailPlanes);
                console.log("Special Trail Bonuses Awarded:", specialTrailBonusesAwarded);
                
                // Get all unique plane IDs from chemtrails
                const planeIds = [...new Set(chemtrails.map(trail => trail.planeId))];
                console.log("Active Chemtrail Plane IDs:", planeIds);
                
                // Count chemtrails by plane ID
                const chemtrailsByPlane = {};
                chemtrails.forEach(trail => {
                    if (!chemtrailsByPlane[trail.planeId]) {
                        chemtrailsByPlane[trail.planeId] = 0;
                    }
                    chemtrailsByPlane[trail.planeId]++;
                });
                console.log("Chemtrails by Plane ID:", chemtrailsByPlane);
                
                // Check for special planes that have left the screen but still have chemtrails
                Object.keys(specialTrailPlanes).forEach(planeId => {
                    const isActive = planes.some(p => p.id === planeId);
                    const hasTrails = planeIds.includes(planeId);
                    const bonusAwarded = specialTrailBonusesAwarded[planeId];
                    
                    console.log(`Plane ${planeId} (${specialTrailPlanes[planeId].trailType}): Active=${isActive}, HasTrails=${hasTrails}, BonusAwarded=${bonusAwarded}`);
                });
                
                // Show a message to indicate the debug info was logged
                messages.push(new CenterMessage("DEBUG INFO LOGGED", '#00ffff', 35, 120));
                
                cheatsInput = "";
                cheatcodeInput.value = "";
            }

            // Check for "SKULL" cheat code to spawn a skull collectible
            if (cheatsInput.includes("SKULL")) {
                // Spawn skull collectible in a safe position
                const x = canvas.width / 2;
                const y = canvas.height / 4;
                
                // Create the skull collectible
                const skull = new SkullCollectible(x, y);
                collectibles.push(skull);
                
                // Show message
                messages.push(new CenterMessage("SKULL SPAWNED!", '#ff0000', 40, 180));
                
                // Reset cheat input
                cheatsInput = "";
                cheatcodeInput.value = "";
                
                console.log("Skull collectible spawned at", x, y);
            }

            // Check for "NPC" cheat code to spawn an NPC plane
            if (cheatsInput.includes("NPC")) {
                try {
                    // Create an NPC plane using the dedicated function
                    const npcPlane = createNPCPlane();
                    planes.push(npcPlane);
                    
                    // Show message
                    messages.push(new CenterMessage("NPC PLANE SPAWNED!", '#808080', 40, 180));
                    
                    // Reset cheat input
                    cheatsInput = "";
                    cheatcodeInput.value = "";
                    
                    console.log("NPC plane created with ID:", npcPlane.id, "and trail type:", npcPlane.trailType);
                } catch (e) {
                    console.error("Error creating NPC plane:", e);
                }
            }
            
            // Check for "DEATH" cheat code to activate Death Mode
            if (cheatsInput.includes("DEATH")) {
                try {
                    // Activate Death Mode
                    deathMode = true;
                    deathModeTimer = 900; // 15 seconds at 60fps
                    deathModeSpawnCount = 0;
                    
                    // Keep existing planes instead of clearing them
                    // planes = []; -- Removed this line to keep existing planes
                    
                    // Spawn an initial NPC plane immediately to verify functionality
                    const initialPlane = createNPCPlane();
                    planes.push(initialPlane);
                    deathModeSpawnCount++;
                    console.log("Initial NPC plane spawned for Death Mode:", initialPlane);
                    
                    // Display announcement
                    messages.push(new CenterMessage("DEATH MODE ACTIVATED", '#ff0000', 40, 180));
                    messages.push(new CenterMessage("40 NPC PLANES INCOMING", '#ff0000', 30, 180)); // Changed from 50 to 40
                    updateCenterMessagePositions();
                    
                    // Play Death Mode sound
                    if (soundEnabled) {
                        playModeMusic('death');
                    }
                    
                    // Reset cheat input
                    cheatsInput = "";
                    cheatcodeInput.value = "";
                    
                    console.log("Death Mode activated - will spawn 40 NPC planes over 15 seconds"); // Changed from 50 to 40
                } catch (e) {
                    console.error("Error activating Death Mode:", e);
                }
            }
        });

        function updateUpgrades() {
            try {
                sizeBtn.classList.toggle('active', sizeLevel < sizeUpgradeCosts.length && score >= sizeUpgradeCosts[sizeLevel]);
                styleBtn.classList.toggle('active', styleLevel < styleUpgradeCosts.length && score >= styleUpgradeCosts[styleLevel]);
                shootBtn.classList.toggle('active', (shootLevel === 0 && score >= shootUpgradeCosts[0]) || 
                                       (shootLevel === 1 && score >= shootUpgradeCosts[1]) ||
                                       (shootLevel === 2 && score >= shootUpgradeCosts[2]) ||
                                       (shootLevel === 3 && score >= shootUpgradeCosts[3]));
                
                // Update button text for shoot upgrade levels
                if (shootLevel === 0) {
                    shootBtn.textContent = "???";
                } else if (shootLevel === 1) {
                    shootBtn.textContent = "Auto-Fire";
                } else if (shootLevel === 2) {
                    shootBtn.textContent = "One Shot";
                } else if (shootLevel === 3) {
                    shootBtn.textContent = "Venom";
                } else {
                    shootBtn.textContent = "MAX";
                }
            } catch (e) {
                console.error("Error updating upgrades:", e);
            }
        }
        
        // Get plane spawn interval based on game time
        function getPlaneSpawnInterval() {
            // Calculate progress (0 to 1) of spawn rate ramp-up
            const progress = Math.min(1, gameTime / SPAWN_RAMP_UP_TIME);
            
            // Use easeInOutQuad to make the transition smoother
            const easedProgress = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
            // Calculate spawn interval - high at start, gradually decreasing to MIN_SPAWN_INTERVAL
            const interval = MAX_SPAWN_INTERVAL - (MAX_SPAWN_INTERVAL - MIN_SPAWN_INTERVAL) * easedProgress;
            
            // If star mode is active, reduce spawn interval by 50% to double the spawn rate
            const finalInterval = Math.round(interval); // No spawn rate multiplier in star mode
            
            // Debug output to verify the interval
            if (starTimer > 0) {
                console.log(`STAR MODE: Using normal spawn interval: ${finalInterval}`);
            }
            
            return finalInterval;
        }

        // Performance monitoring variables
        let lastFrameTime = 0;
        let frameTimes = [];
        let slowFramesCount = 0;
        let perfLoggingEnabled = true;
        let perfLogInterval = 300; // Log every 5 seconds (at 60fps)
        let perfLogCounter = 0;
        let lastObjectCounts = {};

        // Function to force game over
        function forceGameOver(reason) {
            if (gameOver) return; // Don't trigger multiple times
            
            console.log("FORCE GAME OVER: " + reason);
            
            // Capture the current frame
            try {
                // Create a new canvas element to hold the frozen frame
                const frozenCanvas = document.createElement('canvas');
                frozenCanvas.width = canvas.width;
                frozenCanvas.height = canvas.height;
                frozenCanvas.id = 'frozen-game-canvas';
                frozenCanvas.style.position = 'absolute';
                frozenCanvas.style.top = canvas.offsetTop + 'px';
                frozenCanvas.style.left = canvas.offsetLeft + 'px';
                frozenCanvas.style.zIndex = '9'; // Below game over screen but above other elements
                frozenCanvas.style.filter = 'blur(5px)'; // Apply blur to the frozen canvas
                
                // Draw the current game state to the frozen canvas
                const frozenCtx = frozenCanvas.getContext('2d');
                frozenCtx.drawImage(canvas, 0, 0);
                
                // Add a dark overlay to the frozen canvas
                frozenCtx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent black
                frozenCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Insert the frozen canvas into the DOM
                canvas.parentNode.insertBefore(frozenCanvas, canvas);
                
                // Store the frozen canvas for potential cleanup later
                lastFrameImageData = frozenCanvas;
                
                console.log("Frozen canvas created and added to DOM");
            } catch (e) {
                console.error("Failed to capture frame:", e);
            }
            
            // Set game over state
            gameOver = true;
            
            // Update only the points in the game over screen
            const pointsElement = document.querySelector('#game-over-text .points');
            if (pointsElement) {
                pointsElement.textContent = `Total Points: ${totalScore}`;
            } else {
                // Fallback if the structure has changed
                gameOverText.innerHTML = `<h1>GAME OVER</h1><p class="points">Total Points: ${totalScore}</p><p class="message">Deutschland ist komplett verseucht<br>und DU allein bist Schuld!</p><button id="play-again-btn">Play again</button>`;
                
                // Reattach event listener to the play-again button since we recreated it
                const playAgainBtn = document.getElementById('play-again-btn');
                if (playAgainBtn) {
                    playAgainBtn.addEventListener('click', () => {
                        resetGame();
                        startGame();
                    });
                }
            }
            
            // Ensure game over div is properly displayed
            gameOverDiv.style.zIndex = '10';
            gameOverDiv.style.position = 'absolute'; // Changed from 'relative' to 'absolute'
            gameOverDiv.style.display = 'flex';
            gameOverDiv.style.background = 'rgba(0, 0, 0, 0.7)'; // Ensure the background is semi-transparent
            
            // Make cursor visible but don't blur the main canvas
            canvas.style.cursor = 'default';
            
            // Update high score if needed
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            
            // Stop all music and sound effects, then play game over music
            if (soundEnabled) {
                try {
                    // Stop all background music
                    if (music) music.pause();
                    if (schwurblerMusic) schwurblerMusic.pause();
                    if (starSound) starSound.pause();
                    if (ownMusic) ownMusic.pause();
                    if (skullSound) skullSound.pause();
                    
                    // Stop all sound effects
                    if (shotSound) shotSound.pause();
                    if (explodeSound) explodeSound.pause();
                    if (twinkleSound) twinkleSound.pause();
                    if (messageSound) messageSound.pause();
                    if (message2Sound) message2Sound.pause();
                    if (hoverSound) hoverSound.pause();
                    if (clickSound) clickSound.pause();
                    if (killSound) killSound.pause();
                    if (kill2Sound) kill2Sound.pause();
                    if (kill3Sound) kill3Sound.pause();
                    if (kill4Sound) kill4Sound.pause();
                    if (kill5Sound) kill5Sound.pause();
                    if (kill6Sound) kill6Sound.pause();
                    if (kill7Sound) kill7Sound.pause();
                    if (lifeSound) lifeSound.pause();
                    if (alarmSound) alarmSound.pause();
                    if (bestSound) bestSound.pause();
                    
                    // Reset any audio elements that might be created dynamically
                    document.querySelectorAll('audio').forEach(audio => {
                        if (audio !== skyMusic) { // Don't stop skyMusic if it's already playing
                            audio.pause();
                        }
                    });
                    
                    // Play game over music (sky.mp3)
                    playModeMusic('gameover');
                    console.log("All sounds stopped, playing game over music (sky.mp3)");
                } catch (e) { 
                    console.error("Sound management during game over failed:", e); 
                }
            }
        }

        // Add this at the beginning of the main game loop, before any processing
        function gameLoop(timestamp) {
            try {
                if (!gameStarted) {
                    updateStartScreen();
                    requestAnimationFrame(gameLoop);
                    return;
                }
                if (gameOver) {
                    // If we have a captured last frame, draw it instead of clearing the screen
                    if (lastFrameImageData) {
                        ctx.putImageData(lastFrameImageData, 0, 0);
                    }
                    requestAnimationFrame(gameLoop);
                    return;
                }
                
                // FPS monitoring
                const currentFrameTime = performance.now();
                const deltaTime = currentFrameTime - lastFrameTime;
                frameTimes.push(deltaTime);
                if (frameTimes.length > 60) {
                    frameTimes.shift();
                }
                lastFrameTime = currentFrameTime;
                
                // Performance monitoring - track slow frames
                if (deltaTime > 33) { // Frames taking longer than 33ms (less than 30fps)
                    slowFramesCount++;
                }
                
                // Object counts for monitoring
                const objectCounts = {
                    planes: planes.length,
                    chemtrails: chemtrails.length,
                    particles: particles.length,
                    sprayParticles: (typeof sprayParticles !== 'undefined') ? sprayParticles.length : 0,
                    explosions: explosions.length,
                    messages: messages.length,
                    collectibles: collectibles.length,
                    fallingPlanes: fallingPlanes.length,
                    totalObjects: 0,
                };
                
                objectCounts.totalObjects = Object.values(objectCounts).reduce((a, b) => a + b, 0) - objectCounts.totalObjects;
                
                // Log performance data periodically
                if (perfLoggingEnabled) {
                    perfLogCounter++;
                    if (perfLogCounter >= perfLogInterval) {
                        const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
                        const avgFPS = 1000 / avgFrameTime;
                        
                        console.log(`%c==== PERFORMANCE DATA ====`, 'font-weight:bold; color:blue;');
                        console.log(`Average FPS: ${avgFPS.toFixed(1)}`);
                        console.log(`Average frame time: ${avgFrameTime.toFixed(1)}ms`);
                        console.log(`Slow frames (>33ms): ${slowFramesCount} (${(slowFramesCount / perfLogInterval * 100).toFixed(1)}%)`);
                        console.log(`Object counts:`, objectCounts);
                        
                        // Track which object types are growing the most
                        if (lastObjectCounts.totalObjects) {
                            console.log(`Growth since last check:`);
                            for (const [key, count] of Object.entries(objectCounts)) {
                                const growth = count - (lastObjectCounts[key] || 0);
                                if (growth !== 0) {
                                    console.log(`  ${key}: ${growth > 0 ? '+' : ''}${growth}`);
                                }
                            }
                        }
                        
                        // If FPS is low, identify potential bottlenecks
                        if (avgFPS < 45) {
                            console.log(`%cPOTENTIAL BOTTLENECK DETECTED`, 'color:red; font-weight:bold;');
                            
                            // Check for large number of objects
                            if (objectCounts.chemtrails > 500) {
                                console.log(`%cLarge number of chemtrails: ${objectCounts.chemtrails}`, 'color:red;');
                            }
                            if (objectCounts.particles > 200) {
                                console.log(`%cLarge number of particles: ${objectCounts.particles}`, 'color:red;');
                            }
                            if (objectCounts.sprayParticles > 200) {
                                console.log(`%cLarge number of spray particles: ${objectCounts.sprayParticles}`, 'color:red;');
                            }
                            if (objectCounts.planes > 20) {
                                console.log(`%cLarge number of planes: ${objectCounts.planes}`, 'color:red;');
                            }
                        }
                        
                        lastObjectCounts = {...objectCounts};
                        perfLogCounter = 0;
                        slowFramesCount = 0;
                    }
                }

                // Remaining game loop code...
                
                // Always ensure the game loop continues
                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error("Error in game loop:", e);
                // Ensure the game loop continues even if there's an error
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize chemtrail spraying
        let sprayActive = false;
        
        // Enable performance monitoring
        perfLoggingEnabled = true; // Set to true to enable performance logging

        function animate() {
            // PERFORMANCE MONITORING - Variables for performance tracking
            const now = performance.now();
            const elapsed = lastFrameTime ? now - lastFrameTime : 0;
            lastFrameTime = now;
            
            // Performance optimization - handle particles and cleanup offscreen chemtrails
            if (CONFIG.PERFORMANCE.OPTIMIZE_PARTICLES) {
                // Limit the number of particles for better performance
                if (particles.length > 200) {
                    // Remove oldest particles when there are too many
                    particles.splice(0, particles.length - 200);
                }
            }
            
            // Clean up offscreen chemtrails completely (not just skip rendering)
            if (CONFIG.PERFORMANCE.REMOVE_OFFSCREEN_TRAILS) {
                const margin = CONFIG.PERFORMANCE.OFF_SCREEN_MARGIN;
                
                for (let i = chemtrails.length - 1; i >= 0; i--) {
                    const trail = chemtrails[i];
                    
                    // Check if chemtrail is completely offscreen
                    if (
                        (trail.x1 < -margin && trail.x2 < -margin) || 
                        (trail.x1 > canvas.width + margin && trail.x2 > canvas.width + margin) ||
                        (trail.y1 < -margin && trail.y2 < -margin) || 
                        (trail.y1 > canvas.height + margin && trail.y2 > canvas.height + margin)
                    ) {
                        // Remove the trail from the array to save memory and improve performance
                        chemtrails.splice(i, 1);
                    }
                }
            }
            
            // Track frame times for performance analysis
            if (elapsed > 0) {
                frameTimes.push(elapsed);
                if (frameTimes.length > 60) frameTimes.shift(); // Keep last 60 frames
                
                // Count slow frames
                if (elapsed > 33) { // Frames taking longer than 33ms (less than 30 FPS)
                    slowFramesCount++;
                }
            }
            
            if (!ctx) {
                console.error("Canvas context not initialized!");
                return;
            }

            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, isInverted ? '#b2f181' : '#4d0e7e');
                gradient.addColorStop(0.5, isInverted ? '#02b6e1' : '#fd491e');
                gradient.addColorStop(1, isInverted ? '#012bcf' : '#fed430');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate chemtrail density for warning effects
                let warningTrailLength = chemtrails.reduce((sum, t) => sum + Math.hypot(t.x2 - t.x1, t.y2 - t.y1), 0);
                let warningChemtrailDensity = (warningTrailLength * 3) / (canvas.width * canvas.height);
                
                // Update Trail Density display with text status instead of digits
                const densityPercentage = warningChemtrailDensity * 1000; // Using the multiplied value as requested
                let statusText = '';
                let statusColor = '';
                
                // Determine status text and color based on density percentage
                if (chemtrails.length === 0 || densityPercentage < 0.5) {
                    // "NONE" when there are no chemtrails (zero or very close to zero)
                    statusText = 'NONE';
                    statusColor = 'white'; // White color
                    
                    // Force a check for the Sky is Clean message when density is effectively zero
                    if (gameTime >= 300 && !skyCleanMessageShown) {
                        console.log("DENSITY IS VERY LOW - Scheduling Sky is Clean check. Density:", densityPercentage);
                        setTimeout(() => {
                            // Calculate current trail length for a fresh check
                            const currentTrailLength = chemtrails.reduce((sum, t) => sum + Math.hypot(t.x2 - t.x1, t.y2 - t.y1), 0);
                            const currentDensity = (currentTrailLength * 3) / (canvas.width * canvas.height);
                            const currentPercentage = currentDensity * 1000;
                            
                            // This triggers in the next frame to avoid conflicts
                            if ((chemtrails.length === 0 || currentPercentage < 0.02) && !skyCleanMessageShown) {
                                console.log("FORCE TRIGGERING CLEAN SKY DETECTION! Chemtrails:", chemtrails.length, "Density:", currentPercentage);
                                
                                // Force a new center message for clean sky with high visibility
                                const skyMsg = new CenterMessage("THE SKY IS CLEAN!", '#ffffff', 50, 240);
                                messages.push(skyMsg);
                                console.log("Added sky clean message to messages array (forced trigger)");
                                
                                // Force immediate display of the message
                                skyMsg.draw();
                                
                                skyCleanMessageShown = true;
                                
                                // Add bonus points for clean sky
                                const cleanSkyBonus = 5000; // Increased bonus for cleaning the sky
                                addPoints(cleanSkyBonus);
                                updateScoreDisplay();
                                
                                // Add another message for the bonus points
                                messages.push(new CenterMessage(`+${cleanSkyBonus} POINTS`, '#ffff00', 35, 180));
                                
                                // Play the best.mp3 sound, then revert to background music
                                if (soundEnabled) {
                                    // Play clean sky music
                                    playModeMusic('clean');
                                }
                            }
                        }, 0);
                    }
                } else if (densityPercentage <= 10) {
                    statusText = 'HEALTHY';
                    statusColor = 'lime'; // Green
                } else if (densityPercentage <= 30) {
                    statusText = 'OKAY';
                    statusColor = 'dodgerblue'; // Blue
                } else if (densityPercentage <= 50) {
                    statusText = 'OH-OH';
                    statusColor = 'orange';
                } else if (densityPercentage <= 69) {
                    statusText = 'DANGER';
                    statusColor = 'red';
                } else if (densityPercentage <= 80) {
                    statusText = 'CRITICAL';
                    statusColor = 'hotpink'; // Pink
                } else {
                    statusText = 'CERTAIN DEATH';
                    statusColor = 'white';
                    
                    // Trigger game over when density reaches CERTAIN DEATH level
                    if (!gameOver) {
                        console.log("Trail density reached CERTAIN DEATH level. Ending game.");
                        forceGameOver("Chemtrail density reached CERTAIN DEATH level: " + densityPercentage.toFixed(1) + "%");
                    }
                }
                
                // Update or create trail density display
                if (document.getElementById('density')) {
                    const densityElement = document.getElementById('density');
                    densityElement.textContent = `Trail Density: ${statusText}`;
                    densityElement.style.color = statusColor;
                    // Apply the same styling to existing density display
                    densityElement.style.padding = '5px 10px';
                    densityElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    densityElement.style.borderRadius = '10px';
                    // Position to the left of the sound toggle button
                    densityElement.style.top = '10px';
                    densityElement.style.left = 'auto';
                    densityElement.style.right = '60px';
                } else {
                    // Create Trail Density display if it doesn't exist
                    const densityDisplay = document.createElement('div');
                    densityDisplay.id = 'density';
                    densityDisplay.style.position = 'absolute';
                    densityDisplay.style.left = 'auto'; // Clear left position
                    densityDisplay.style.right = '60px'; // Position to the left of the sound toggle button
                    densityDisplay.style.top = '10px'; // Align with the sound toggle button
                    densityDisplay.style.color = statusColor;
                    densityDisplay.style.fontFamily = 'Arial, sans-serif';
                    densityDisplay.style.fontSize = '18px';
                    densityDisplay.style.textShadow = '2px 2px 2px black';
                    densityDisplay.style.padding = '5px 10px'; // Add padding inside the box
                    densityDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent black background
                    densityDisplay.style.borderRadius = '10px'; // Rounded edges
                    densityDisplay.textContent = `Trail Density: ${statusText}`;
                    document.body.appendChild(densityDisplay);
                }
                
                // Add visual warning when approaching game over threshold or when cheat code is active
                if ((warningChemtrailDensity > 0.06 && !gameOver) || forceCriticalDensity) { // Added forceCriticalDensity check
                    // Red vignette effect that intensifies as density approaches threshold
                    // If using cheat code, set intensity to maximum
                    const intensity = forceCriticalDensity ? 0.5 : Math.min(0.5, (warningChemtrailDensity - 0.06) * 12);
                    
                    // Save the current drawing state before applying the warning effect
                    ctx.save();
                    
                    // Create radial gradient for vignette effect
                    const gradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 10,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                    gradient.addColorStop(0.7, `rgba(255, 0, 0, ${intensity.toFixed(2)})`);
                    gradient.addColorStop(1, `rgba(255, 0, 0, ${intensity.toFixed(2)})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Warning text that flashes
                    if (Math.floor(gameTime / 15) % 2 === 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = '16px "Press Start 2P", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('WARNING: CHEMTRAIL DENSITY CRITICAL', canvas.width / 2 + 50, 30); // Moved 50px to the right
                    }
                    
                    // Restore the drawing state after applying the warning effect
                    ctx.restore();
                    
                    // Play alarm sound if it's not already playing
                    if (soundEnabled && alarmSound.paused) {
                        alarmSound.currentTime = 0;
                        alarmSound.loop = true;
                        alarmSound.volume = 0.15; // Set to 15% volume so it's much less jarring
                        alarmSound.play().catch(e => console.log("Alarm sound failed to play:", e));
                    }
                } else {
                    // Stop alarm sound if it's playing and we're no longer in critical density or game is over
                    if (!forceCriticalDensity && !alarmSound.paused) { // Only stop if not forced by cheat code
                        alarmSound.pause();
                        alarmSound.currentTime = 0;
                    }
                    
                    // Reset the force flag if game is over
                    if (gameOver) {
                        forceCriticalDensity = false;
                    }
                }

                clouds.forEach(cloud => {
                    // Only update position if game is not over
                    if (!gameOver) {
                        cloud.update();
                    }
                    cloud.draw();
                });

                if (gameStarted && !gameOver) {
                    // Set gameHasStarted to true after a short delay
                    if (gameTime > 60) {
                        gameHasStarted = true;
                    }
                    
                    // Handle auto-fire for level 2+ (continuous shooting while mouse is held down)
                    if (shootLevel >= 2 && isMouseDown && shotCooldown <= 0 && targetMode && targetPlane) {
                        fireShot();
                    }
                    
                    // Check for target mode on each frame
                    if (shootLevel > 0) {
                        targetMode = false;
                        targetPlane = null;
                        for (let i = planes.length - 1; i >= 0; i--) {
                            const plane = planes[i];
                            const width = 75.3 * plane.sizeFactor;
                            const height = 32.1 * plane.sizeFactor;
                            const targetWidth = width * 1.4;
                            const targetHeight = height * 1.4;
                            if (mouseX >= plane.x - targetWidth / 2 && mouseX <= plane.x + targetWidth / 2 &&
                                mouseY >= plane.y - targetHeight / 2 && mouseY <= plane.y + targetHeight / 2) {
                                targetMode = true;
                                targetPlane = plane;
                                break;
                            }
                        }
                    }
                    
                    for (let i = chemtrails.length - 1; i >= 0; i--) {
                        const trail = chemtrails[i];
                        
                        const dist = pointLineDistance(mouseX, mouseY, trail.x1, trail.y1, trail.x2, trail.y2);
                        // Slightly increase the base cleanup distance for better cleaning
                        const baseCleanupDistance = starTimer > 0 ? cursorSizes[sizeLevel] / 1.5 : Math.max(cursorSizes[sizeLevel] / 3, 12);
                        
                        // Add magnetic effect - trails get pulled in more easily when moving the cursor
                        const magneticEffect = isMouseDown ? 1.1 : 1.0; // 10% larger radius instead of 20%
                        const cleanupDistance = baseCleanupDistance * magneticEffect;
                        
                        if (dist < cleanupDistance) {
                            // Create a more dynamic particle effect
                            const particleCount = CONFIG.PERFORMANCE.OPTIMIZE_PARTICLES ? 3 : 5;
                            for (let j = 0; j < particleCount; j++) {
                                const t = j / (particleCount - 1);
                                const particle = new Particle(
                                    trail.x1 + (trail.x2 - trail.x1) * t, 
                                    trail.y1 + (trail.y2 - trail.y1) * t
                                );
                                
                                // Remove the magnetic effect while keeping original particle behavior
                                // Original particles will still appear but won't be pulled toward cursor
                                
                                particles.push(particle);
                            }
                            
                            // Apply point multipliers for special trails
                            // Set fixed point values based on trail type
                            
                            // Calculate the length of the trail segment in pixels
                            const trailLength = Math.hypot(trail.x2 - trail.x1, trail.y2 - trail.y1);
                            
                            // Base points: 1 point per pixel for standard trails
                            // But we'll accumulate and only count in units of 100
                            let rawPoints = Math.round(trailLength);
                            
                            // Adjust points based on trail type
                            if (trail.trailType === 'repto') {
                                rawPoints = Math.round(trailLength * 2); // 2 points per pixel
                            } else if (trail.trailType === 'rainbow') {
                                rawPoints = Math.round(trailLength * 3); // 3 points per pixel
                            } else if (trail.trailType === 'npc') {
                                rawPoints = Math.round(trailLength * 1.5); // 1.5 points per pixel
                            }
                            
                            // We'll accumulate these raw points but not add them to the score yet
                            // Add debug log to show the actual points being calculated
                            console.log(`Trail cleaning: Trail type: ${trail.trailType || 'normal'}, Length: ${trailLength.toFixed(1)}px, Raw points: ${rawPoints}`);
                            
                            // Track accumulated points for +100 indicators
                            if (!window.trailPointsAccumulator) {
                                window.trailPointsAccumulator = 0;
                            }
                            
                            // Add to accumulator
                            window.trailPointsAccumulator += rawPoints;
                            
                            // Check if we've reached 100 points
                            if (window.trailPointsAccumulator >= 100) {
                                // Calculate how many +100 indicators to show
                                const indicatorCount = Math.floor(window.trailPointsAccumulator / 100);
                                const pointsToAdd = indicatorCount * 100;
                                
                                // Add the points to the score
                                addPoints(pointsToAdd);
                                
                                // Create indicators
                                for (let k = 0; k < indicatorCount; k++) {
                                    // Calculate position along the trail
                                    const trailX = trail.x1 + (trail.x2 - trail.x1) * 0.5;
                                    const trailY = trail.y1 + (trail.y2 - trail.y1) * 0.5;
                                    
                                    // Determine color based on trail type
                                    let indicatorColor = '#ffffff'; // Default white
                                    
                                    if (trail.trailType === 'repto') {
                                        indicatorColor = '#39FF14'; // Neon green
                                    } else if (trail.trailType === 'rainbow') {
                                        indicatorColor = '#ff0000'; // Red for rainbow trails
                                    } else if (trail.trailType === 'npc') {
                                        indicatorColor = '#808080'; // Middle grey
                                    }
                                    
                                    // Create the indicator - explicitly set size to 16 (default)
                                    const indicator = new Message("+100", trailX, trailY, indicatorColor, 16, 60);
                                    messages.push(indicator);
                                }
                                
                                // Subtract the used points from the accumulator
                                window.trailPointsAccumulator -= pointsToAdd;
                            }
                            
                            // Track plane trail segments
                            if (trail.planeId) {
                                // Initialize if this is the first segment from this plane
                                if (!planeTrailSegments[trail.planeId]) {
                                    planeTrailSegments[trail.planeId] = {
                                        totalSegments: 0,
                                        clearedSegments: 0,
                                        trailType: trail.trailType,
                                        trailMessage: trail.trailMessage
                                    };
                                    
                                    // Find the plane in the planes array to get total segment count
                                    const plane = planes.find(p => p.id === trail.planeId);
                                    if (plane) {
                                        planeTrailSegments[trail.planeId].totalSegments = plane.trailSegmentCount;
                                    }
                                }
                                
                                // Increment cleared segments
                                planeTrailSegments[trail.planeId].clearedSegments++;
                                
                                // Check if all segments for this plane are cleared
                                const planeTrail = planeTrailSegments[trail.planeId];
                                
                                // Debug logging to help diagnose issues
                                console.log(`Trail cleared: Plane ID ${trail.planeId}, Trail type: ${planeTrail.trailType || 'normal'}, Cleared: ${planeTrail.clearedSegments}/${planeTrail.totalSegments}`);
                                
                                // Only award bonus when ALL segments are cleared AND the plane is no longer active
                                // This ensures the entire trail must be cleared before awarding the bonus
                                if (planeTrail.clearedSegments >= planeTrail.totalSegments && 
                                    !planeTrailsCleared[trail.planeId]) {
                                    
                                    // Check if the plane is still active (still creating trails)
                                    const planeStillActive = planes.some(p => p.id === trail.planeId);
                                    
                                    // Check if there are any remaining trails from this plane
                                    const remainingTrails = chemtrails.filter(t => 
                                        t.planeId === trail.planeId && 
                                        t !== trail // Exclude the current trail being cleared
                                    ).length;
                                    
                                    // More detailed debug logging to diagnose trail bonus issues
                                    console.log(`Bonus check: Plane ${trail.planeId}, Active: ${planeStillActive}, Remaining trails: ${remainingTrails}, Segments cleared: ${planeTrail.clearedSegments}/${planeTrail.totalSegments}, Trail type: "${planeTrail.trailType || 'normal'}"`);
                                    
                                    // Only award bonus if the plane is no longer active AND all trails are cleared
                                    if (!planeStillActive && remainingTrails === 0) {
                                        // Mark as cleared
                                        planeTrailsCleared[trail.planeId] = true;
                                        
                                        // Record the time this bonus was awarded
                                        lastTrailBonusTime = gameTime;
                                        
                                        // Show bonus message for the complete trail
                                        let msgColor, bonusAmount, bonusMessage;
                                        
                                        // Ensure trailType is defined, default to 'normal' if not set
                                        const trailTypeSafe = planeTrail.trailType || 'normal';
                                        
                                        // Get the plane info from the registry if available
                                        const registeredPlane = specialTrailPlanes[trail.planeId];
                                        
                                        // Log the registered plane info for debugging
                                        console.log(`Registered plane info:`, registeredPlane ? 
                                            `Type: ${registeredPlane.trailType}, Message: ${registeredPlane.trailMessage}` : 
                                            'Not found in registry');
                                        
                                        // Use the safe trail type for determining the bonus
                                        if (trailTypeSafe === 'repto') {
                                            msgColor = '#39FF14'; // Neon green
                                            bonusAmount = 2000; // 2.000 points
                                            bonusMessage = "REPTO TRAIL BONUS";
                                        } else if (trailTypeSafe === 'rainbow') {
                                            msgColor = '#ff00ff'; // Magenta
                                            bonusAmount = 4000; // 4.000 points
                                            bonusMessage = "INSTA-GAY TRAIL BONUS";
                                        } else if (trailTypeSafe === 'npc') {
                                            msgColor = '#808080'; // Middle grey
                                            bonusAmount = 3000; // 3.000 points
                                            bonusMessage = "NPC ERROR BONUS!";
                                        } else {
                                            // Normal planes - ensure this default case always runs when not one of the above
                                            msgColor = '#ffffff'; // White
                                            bonusAmount = 1000; // 1.000 points
                                            bonusMessage = "TRAIL BUSTER";
                                            
                                            // Extra debug for normal planes
                                            console.log("Normal trail bonus triggered!");
                                        }
                                        
                                        // Override with registered message if available
                                        if (registeredPlane && registeredPlane.trailMessage) {
                                            bonusMessage = registeredPlane.trailMessage;
                                        }
                                        
                                        console.log(`Trail bonus determined: Type "${trailTypeSafe}", Message: "${bonusMessage}", Amount: ${bonusAmount}`);
                                        
                                        // Show the bonus message
                                        addCenterMessage(bonusMessage, msgColor, 40, 120);
                                        // Format score with dots after thousands (1.000 instead of 1000)
                                        const formattedBonus = bonusAmount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
                                        addCenterMessage(`+${formattedBonus} POINTS`, '#ffff00', 30, 120);
                                        
                                        // Add bonus points for clearing the full trail
                                        addPoints(bonusAmount);
                                        updateScoreDisplay();
                                        
                                        // Log the bonus award
                                        console.log(`Trail bonus awarded: ${bonusMessage} for ${bonusAmount} points`);
                                    } else {
                                        if (planeStillActive) {
                                            console.log(`Plane ${trail.planeId} is still active - no bonus yet`);
                                        } else if (remainingTrails > 0) {
                                            console.log(`${remainingTrails} trails remaining for plane ${trail.planeId} - no bonus yet`);
                                        }
                                    }
                                }
                            }
                            
                            // Store the trail type for the point indicators
                            window.currentTrailType = trail.trailType || 'normal';
                            
                            // Store the trail ID to ensure we only remove this specific trail
                            const trailId = trail.id || i;
                            
                            try {
                                // Remove only this specific trail
                                if (i >= 0 && i < chemtrails.length) {
                                    // Make sure we're removing the same trail (it might have shifted)
                                    if (chemtrails[i] === trail) {
                                        chemtrails.splice(i, 1);
                                    } else {
                                        // Find the trail by ID if it has moved
                                        const trailIndex = chemtrails.findIndex(t => t.id === trailId);
                                        if (trailIndex >= 0) {
                                            chemtrails.splice(trailIndex, 1);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error("Error processing trail cleanup:", e);
                            }
                            
                            try {
                                updateUpgrades();
                            } catch (e) {
                                console.error("Error updating upgrades after trail cleanup:", e);
                            }
                        }
                    }
                    
                    // After cleaning trails directly under the cursor, clean nearby fragments
                    try {
                        // Only run fragment cleaning every few frames to improve performance
                        if (gameTime % 3 === 0) {
                            const baseCleanupDistance = starTimer > 0 ? cursorSizes[sizeLevel] / 1.5 : Math.max(cursorSizes[sizeLevel] / 3, 12);
                            const fragmentsRemoved = cleanTrailFragments(mouseX, mouseY, baseCleanupDistance);
                            
                            // Remove the vacuum effect particles that hover around the cursor
                            // This keeps only the original particle effect directly on the trails
                        }
                    } catch (e) {
                        console.error("Error in fragment cleaning:", e);
                    }
                    
                    // Batch render chemtrails by type for better performance
                    if (CONFIG.PERFORMANCE.BATCH_RENDERING) {
                        // Group chemtrails by type for batch rendering
                        const normalTrails = [];
                        const reptoTrails = [];
                        const rainbowTrails = [];
                        const npcTrails = [];
                        
                        // First pass: separate trails by type
                        for (let i = 0; i < chemtrails.length; i++) {
                            const trail = chemtrails[i];
                            
                            // Skip rendering trails that are being cleaned (already handled above)
                            const dist = pointLineDistance(mouseX, mouseY, trail.x1, trail.y1, trail.x2, trail.y2);
                            const cleanupDistance = starTimer > 0 ? cursorSizes[sizeLevel] / 1.5 : Math.max(cursorSizes[sizeLevel] / 3, 12);
                            if (dist < cleanupDistance) continue;
                            
                            // Categorize by trail type
                            if (trail.trailType === 'repto') {
                                reptoTrails.push(trail);
                            } else if (trail.trailType === 'rainbow') {
                                rainbowTrails.push(trail);
                            } else if (trail.trailType === 'npc') {
                                npcTrails.push(trail);
                            } else {
                                normalTrails.push(trail);
                            }
                        }
                        
                        // Second pass: batch render each type
                        // Render normal trails
                        if (normalTrails.length > 0) {
                            ctx.beginPath();
                            ctx.lineWidth = 2;  // Default line width
                            ctx.strokeStyle = invertColor('#ffffff');  // Use invertColor function
                            
                            for (const trail of normalTrails) {
                                ctx.moveTo(trail.x1, trail.y1);
                                ctx.lineTo(trail.x2, trail.y2);
                            }
                            
                            ctx.stroke();
                        }
                        
                        // Render repto trails
                        if (reptoTrails.length > 0) {
                            const reptoColor = invertColor('#39FF14'); // Use invertColor function
                            ctx.beginPath();
                            ctx.lineWidth = 2;  // Repto line width
                            ctx.strokeStyle = reptoColor;
                            
                            for (const trail of reptoTrails) {
                                ctx.moveTo(trail.x1, trail.y1);
                                ctx.lineTo(trail.x2, trail.y2);
                            }
                            
                            ctx.stroke();
                        }
                        
                        // Render military trails
                        if (npcTrails.length > 0) {
                            const npcColor = invertColor('#465064'); // Use invertColor function
                            ctx.beginPath();
                            ctx.lineWidth = 4;  // Military trails are thicker
                            ctx.strokeStyle = npcColor;
                            
                            for (const trail of npcTrails) {
                                ctx.moveTo(trail.x1, trail.y1);
                                ctx.lineTo(trail.x2, trail.y2);
                            }
                            
                            ctx.stroke();
                        }
                        
                        // Rainbow trails need individual rendering due to color variation
                        for (const trail of rainbowTrails) {
                            ctx.beginPath();
                            ctx.lineWidth = trail.lineWidth;
                            
                            // Calculate rainbow color and use invertColor function
                            const hue = (gameTime * 2) % 360;
                            const rainbowColor = `hsl(${hue}, 100%, 50%)`;
                            ctx.strokeStyle = invertColor(rainbowColor);
                            
                            ctx.moveTo(trail.x1, trail.y1);
                            ctx.lineTo(trail.x2, trail.y2);
                            ctx.stroke();
                        }
                        
                        // Render NPC trails
                        if (npcTrails.length > 0) {
                            const npcColor = invertColor('#808080'); // Use invertColor function
                            ctx.beginPath();
                            ctx.lineWidth = 5;  // NPC trails are thicker
                            ctx.strokeStyle = npcColor;
                            
                            for (const trail of npcTrails) {
                                ctx.moveTo(trail.x1, trail.y1);
                                ctx.lineTo(trail.x2, trail.y2);
                            }
                            
                            ctx.stroke();
                        }
                    } else {
                        // Original individual rendering code
                        for (let i = 0; i < chemtrails.length; i++) {
                            const trail = chemtrails[i];
                            
                            // Skip rendering trails that are being cleaned
                            const dist = pointLineDistance(mouseX, mouseY, trail.x1, trail.y1, trail.x2, trail.y2);
                            const cleanupDistance = starTimer > 0 ? cursorSizes[sizeLevel] / 1.5 : Math.max(cursorSizes[sizeLevel] / 3, 12);
                            if (dist < cleanupDistance) continue;
                            
                            ctx.beginPath();
                            ctx.lineWidth = trail.lineWidth;
                            
                            // Different rendering based on trail type
                            if (trail.trailType === 'repto') {
                                // Neon green trail - use invertColor function
                                const reptoColor = invertColor('#39FF14');
                                ctx.strokeStyle = reptoColor;
                            } else if (trail.trailType === 'rainbow') {
                                // Calculate rainbow color
                                const hue = (gameTime * 2) % 360;
                                // Use invertColor function with HSL
                                const rainbowColor = `hsl(${hue}, 100%, 50%)`;
                                ctx.strokeStyle = invertColor(rainbowColor);
                            } else if (trail.trailType === 'npc') {
                                // NPC plane trail - use invertColor function
                                const npcColor = invertColor('#808080');
                                ctx.strokeStyle = npcColor;
                            } else {
                                // Regular white chemtrail - use invertColor function
                                ctx.strokeStyle = invertColor('#fff');
                            }
                            
                            ctx.moveTo(trail.x1, trail.y1);
                            ctx.lineTo(trail.x2, trail.y2);
                            ctx.stroke();
                        }
                    }

                    // Update and draw spray particles BEFORE planes to place them behind
                    for (let i = sprayParticles.length - 1; i >= 0; i--) {
                        const spray = sprayParticles[i];
                        spray.update();
                        spray.draw();
                        if (spray.life <= 0) sprayParticles.splice(i, 1);
                    }

                    planes.forEach(plane => {
                        plane.update();
                        plane.draw();
                    });
                    
                    // Update and draw falling planes (from star mode)
                    for (let i = fallingPlanes.length - 1; i >= 0; i--) {
                        const fallingPlane = fallingPlanes[i];
                        
                        // Update returns false when plane should be removed
                        if (!fallingPlane.update()) {
                            fallingPlanes.splice(i, 1);
                            continue;
                        }
                        
                        // Draw the falling plane
                        fallingPlane.draw();
                    }

                    for (let i = shots.length - 1; i >= 0; i--) {
                        if (targetPlane) {
                            shots[i].update();
                            shots[i].draw();
                        } else {
                            shots = [];
                            break;
                        }
                    }

                    for (let i = explosions.length - 1; i >= 0; i--) {
                        const explosion = explosions[i];
                        explosion.update();
                        explosion.draw();
                        if (explosion.life <= 0) explosions.splice(i, 1);
                    }

                    for (let i = particles.length - 1; i >= 0; i--) {
                        const particle = particles[i];
                        particle.update();
                        particle.draw();
                        if (particle.life <= 0) particles.splice(i, 1);
                    }

                    // Update and draw hit indicators
                    for (let i = hitIndicators.length - 1; i >= 0; i--) {
                        hitIndicators[i].update();
                        hitIndicators[i].draw();
                        if (hitIndicators[i].life <= 0) {
                            hitIndicators.splice(i, 1);
                        }
                    }

                    // Calculate total trail length for clean sky detection
                    let cleanSkyTrailLength = chemtrails.reduce((sum, t) => sum + Math.hypot(t.x2 - t.x1, t.y2 - t.y1), 0);
                    let cleanSkyDensity = (cleanSkyTrailLength * 3) / (canvas.width * canvas.height);
                    let cleanSkyPercentage = cleanSkyDensity * 1000;

                    // Check if sky is clean (no or very few chemtrails, regardless of planes)
                    if ((chemtrails.length === 0 || cleanSkyPercentage < 0.02) && !skyCleanMessageShown && gameTime >= 300) {
                        // Don't trigger within first 5 seconds (300 frames at 60fps)
                        
                        // Log detailed debug info
                        console.log("CLEAN SKY DETECTED! Chemtrails:", chemtrails.length, "Density:", cleanSkyPercentage, "Planes:", planes.length, "Game time:", gameTime);
                        
                        // Force a new center message for clean sky with high visibility
                        const skyMsg = new CenterMessage("THE SKY IS CLEAN!", '#ffffff', 50, 240);
                        messages.push(skyMsg);
                        console.log("Added sky clean message to messages array. Current messages:", messages.length);
                        
                        // Force immediate display of the message
                        skyMsg.draw();
                        
                        skyCleanMessageShown = true;
                        lastCleanSkyEventTime = gameTime; // Record when this event occurred
                        cleanSkyEventCount++; // Increment the counter
                        
                        // Add bonus points for clean sky
                        const cleanSkyBonus = 5000; // Increased bonus for cleaning the sky
                        addPoints(cleanSkyBonus);
                        updateScoreDisplay();
                        
                        // Add another message for the bonus points
                        messages.push(new CenterMessage(`+${cleanSkyBonus} POINTS`, '#ffff00', 35, 180));
                        
                        // Play the best.mp3 sound, then revert to background music
                        if (soundEnabled) {
                            // Play clean sky music
                            playModeMusic('clean');
                            
                            // Set up an event to resume background music when best sound ends
                            bestSound.onended = () => {
                                console.log("Best sound finished, returning to background music");
                                // Determine which music to play based on active modes
                                if (onyxTimer > 0) {
                                    playModeMusic('onyx');
                                } else if (schwabMode) {
                                    playModeMusic('schwab');
                                } else if (starTimer > 0) {
                                    playModeMusic('star');
                                } else {
                                    playModeMusic('normal');
                                }
                            };
                        }
                    } else if (chemtrails.length > 5 && cleanSkyPercentage > 2.0) {
                        // Only reset the flag when there are MANY chemtrails to avoid flickering
                        skyCleanMessageShown = false;
                        
                        // Log when the flag is reset
                        console.log("Sky clean flag RESET. Chemtrails:", chemtrails.length, "Density:", cleanSkyPercentage);
                        
                        // Only log occasionally to avoid console spam
                        if (gameTime % 60 === 0) {
                            console.log("Sky not clean. Chemtrails:", chemtrails.length, "Planes:", planes.length);
                        }
                    }
                    
                    // Additional reset condition: If it's been at least 30 seconds (1800 frames) since the last clean sky event
                    // and there are currently some chemtrails, reset the flag to allow another clean sky event
                    if (skyCleanMessageShown && gameTime - lastCleanSkyEventTime > 1800 && chemtrails.length > 0) {
                        skyCleanMessageShown = false;
                        console.log("Sky clean flag RESET due to time elapsed. Allowing new clean sky events. Events so far:", cleanSkyEventCount);
                    }
                    
                    // For each chemtrail, check if it's behind the city skyline
                    const currentTime = Date.now();
                    for (let i = chemtrails.length - 1; i >= 0; i--) {
                        const trail = chemtrails[i];
                        
                        // Check if either end of the trail is behind the skyline (in the bottom portion of the screen)
                        const skylineHeight = 150; // Estimated max height of the tallest buildings
                        const behindSkyline = (trail.y1 > canvas.height - skylineHeight) || (trail.y2 > canvas.height - skylineHeight);
                        
                        // If the trail is behind the skyline, add a removal timestamp if not present
                        if (behindSkyline) {
                            if (!trail.behindSkylineSince) {
                                trail.behindSkylineSince = currentTime;
                            } else if (currentTime - trail.behindSkylineSince > 1000) { // 1 second
                                // Remove the trail after 1 second behind the skyline
                                chemtrails.splice(i, 1);
                            }
                        } else {
                            // Reset the timestamp if the trail is no longer behind the skyline
                            trail.behindSkylineSince = null;
                        }
                    }

                    if (gameTime === CONFIG.SPAWN_RATES.ONYX_FIRST_SPAWN + Math.floor(Math.random() * CONFIG.SPAWN_RATES.ONYX_RANDOM_DELAY) && !onyxTimer) {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height * 0.8;
                        collectibles.push(new OnyxPowerUp(x, y));
                    } else if (gameTime >= 3600 && gameTime - lastSchwabSpawn >= 3600) {
                        // Only spawn Schwab after 1 minute (3600 frames at 60fps) and at least 60 seconds between spawns (reduced spawn rate by 50%)
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height * 0.8;
                        collectibles.push(new SchwabCollectible(x, y));
                        console.log("Forced Schwab spawn at time:", gameTime);
                        lastSchwabSpawn = gameTime;
                    }
                    else if (Math.random() < CONFIG.SPAWN_RATES.NORMAL_SPAWN_CHANCE) {
                        // Spawn collectibles regardless of onyxTimer state
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height * 0.8;
                        const rand = Math.random();
                        
                        // Use configuration values for power-up spawn probabilities
                        const onyxThreshold = CONFIG.POWERUPS.ONYX;
                        const starThreshold = onyxThreshold + CONFIG.POWERUPS.STAR;
                        const skullThreshold = starThreshold + CONFIG.POWERUPS.SKULL;
                        
                        if (rand < onyxThreshold) {
                            collectibles.push(new OnyxPowerUp(x, y));
                        } else if (rand < starThreshold) {
                            collectibles.push(new StarPowerUp(x, y));
                        } else if (rand < skullThreshold) {
                            collectibles.push(new SkullCollectible(x, y));
                            console.log("Skull collectible spawned naturally at", x, y);
                        } else {
                            collectibles.push(new CoinPowerUp(x, y));
                        }
                    }

                    // During star mode, check if cursor is hovering over planes for star power special ability
                    if (starTimer > 0 || venomMode) {
                        for (let i = planes.length - 1; i >= 0; i--) {
                            const plane = planes[i];
                            const width = 75.3 * plane.sizeFactor;
                            const height = 32.1 * plane.sizeFactor;
                            
                            // Enhanced hitbox detection for star and venom modes
                            let hitboxMultiplier = 1.0;
                            
                            // Base hitbox improvement for all size levels
                            if (plane.sizeFactor < 0.5) {
                                // Small planes start with a 120% hitbox
                                hitboxMultiplier = 2.2;
                            } else if (plane.sizeFactor < 2.5) {
                                // Medium planes start with a 100% hitbox
                                hitboxMultiplier = 2.0;
                            } else {
                                // Large planes get a smaller bonus
                                hitboxMultiplier = 1.5;
                            }
                            
                            // Extra boost for the highest size levels (4-5)
                            if (sizeLevel >= 4) {
                                // Apply an additional multiplier based on size level
                                const sizeBoost = 1.0 + ((sizeLevel - 3) * 0.5); // +50% per level above 3
                                hitboxMultiplier *= sizeBoost;
                                
                                // Even more generous for small planes at highest levels
                                if (plane.sizeFactor < 0.5) {
                                    hitboxMultiplier *= 1.3; // Extra 30% for small planes
                                }
                            }
                            
                            // Add a minimum hit area for very small planes to make them easier to hit
                            const minHitWidth = 40 * (sizeLevel >= 4 ? 1.5 : 1.0); // Increased minimum for high levels
                            const minHitHeight = 20 * (sizeLevel >= 4 ? 1.5 : 1.0);
                            
                            // Apply the multiplier to the plane's dimensions
                            const hitWidth = Math.max(width * hitboxMultiplier, minHitWidth);
                            const hitHeight = Math.max(height * hitboxMultiplier, minHitHeight);
                            
                            // Check if cursor is over the plane with the expanded hit area
                            if (mouseX >= plane.x - hitWidth/2 && mouseX <= plane.x + hitWidth/2 &&
                                mouseY >= plane.y - hitHeight/2 && mouseY <= plane.y + hitHeight/2) {
                                
                                // Create a falling plane effect instead of explosion
                                fallingPlanes.push(new FallingPlane(plane));
                                
                                // Remove from planes array
                                planes.splice(i, 1);
                                
                                addPoints(2000);
                                
                                // Only increment consecutive star kill counter and play sounds in star mode, not venom mode
                                if (starTimer > 0) {
                                    // Increment consecutive star kill counter
                                    consecutiveStarKills++;
                                    
                                    // Calculate points based on consecutive hits (linear: 1000, 2000, 3000, 4000, etc.)
                                    const basePoints = 1000;
                                    const pointsEarned = basePoints * consecutiveStarKills;
                                    
                                    // Add points to score
                                    addPoints(pointsEarned);
                                    updateScoreDisplay();
                                    
                                    // Play progressive kill sounds based on consecutive kills
                                    if (soundEnabled) {
                                        try {
                                            // Special bonus after 7 consecutive kills
                                            if (consecutiveStarKills === 7) {
                                                // Add bonus score
                                                addPoints(10000);
                                                updateScoreDisplay();
                                                
                                                // Play special sound
                                                lifeSound.currentTime = 0;
                                                lifeSound.play();
                                                
                                                // Show special message
                                                messages.push(new CenterMessage("PLANE SHREDDER!", "#ff00ff", 40, 180));
                                                messages.push(new CenterMessage("+10000 Points", "#ffff00", 35, 180));
                                            } else {
                                                // Select the appropriate sound based on consecutive kills
                                                let currentKillSound;
                                                switch(Math.min(consecutiveStarKills, 7)) {
                                                    case 1: currentKillSound = killSound; break;
                                                    case 2: currentKillSound = kill2Sound; break;
                                                    case 3: currentKillSound = kill3Sound; break;
                                                    case 4: currentKillSound = kill4Sound; break;
                                                    case 5: currentKillSound = kill5Sound; break;
                                                    case 6: currentKillSound = kill6Sound; break;
                                                    case 7: 
                                                    default: currentKillSound = kill7Sound; break;
                                                }
                                                
                                                currentKillSound.currentTime = 0;
                                                currentKillSound.play();
                                                
                                                // Add center message showing just the points earned
                                                const multiplierColor = getStarModeMultiplierColor(consecutiveStarKills);
                                                messages.push(new CenterMessage(`+${pointsEarned}`, multiplierColor, 30, 120));
                                            }
                                        } catch (e) { console.log("Kill sound failed:", e); }
                                    } else {
                                        // If sound is disabled, still show the message for normal kills
                                        if (consecutiveStarKills === 7) {
                                            messages.push(new CenterMessage("PLANE SHREDDER!", "#ff00ff", 40, 180));
                                            messages.push(new CenterMessage("+10000 Points", "#ffff00", 35, 180));
                                        } else {
                                            // Show just the points message without "double points" text
                                            const multiplierColor = getStarModeMultiplierColor(consecutiveStarKills);
                                            messages.push(new CenterMessage(`+${pointsEarned}`, multiplierColor, 30, 120));
                                        }
                                    }
                                } else if (venomMode) {
                                    // In venom mode, add base score and show a simple message without special effects
                                    addPoints(2000);
                                    updateScoreDisplay();
                                    messages.push(new CenterMessage("+2000", "#00ff00", 25, 90));
                                    
                                    // Play kill.mp3 sound for venom mode
                                    if (soundEnabled) {
                                        try {
                                            killSound.currentTime = 0;
                                            killSound.volume = 0.7;
                                            killSound.play();
                                        } catch (e) { console.log("Venom sound failed:", e); }
                                    }
                                }
                                updateCenterMessagePositions();
                            }
                        }
                    }

                    // Process collectibles
                    for (let i = collectibles.length - 1; i >= 0; i--) {
                        const powerUp = collectibles[i];
                        powerUp.update();
                        powerUp.draw();
                        
                        // Check if player touches powerup
                        const dist = Math.hypot(mouseX - powerUp.x, mouseY - powerUp.y);
                        if (dist < powerUp.size / 2 + cursorSizes[sizeLevel] / 2) {
                            twinkleEffects.push(new Twinkle(powerUp.x, powerUp.y, powerUp.type === 'coin' ? '+10.000' : null));
                            if (soundEnabled) {
                                try { twinkleSound.play(); } catch (e) { console.log("Twinkle sound failed:", e); }
                            }
                            
                            // Add message for power-up collection
                            let message = "";
                            let color = "#fff";
                            
                            // Handling state management for special modes before processing the powerup
                            // End any active special modes when collecting a new powerup
                            if (powerUp.type === 'star' || powerUp.type === 'onyx') {
                                // If this is a special mode powerup, stop any currently active special mode
                                if (starTimer > 0) {
                                    // Reset star mode
                                    starTimer = 0;
                                    cursorFlashing = false;
                                    
                                    // Stop star sound if it's playing
                                    if (soundEnabled && !starSound.paused) {
                                        try {
                                            starSound.pause();
                                            starSound.currentTime = 0;
                                        } catch (e) { console.log("Star sound stop failed:", e); }
                                    }
                                }
                                
                                // Reset onyx/schwurbler mode if active
                                if (onyxTimer > 0) {
                                    // Reset schwurbler mode
                                    onyxTimer = 0;
                                    isInverted = false; // Turn off color inversion
                                    
                                    // Reset game state that might have been altered
                                    document.body.style.backgroundColor = '#000';
                                    canvas.style.filter = 'none';
                                    
                                    // Stop schwurbler music if it's playing
                                    if (soundEnabled && !schwurblerMusic.paused) {
                                        try {
                                            schwurblerMusic.pause();
                                            schwurblerMusic.currentTime = 0;
                                        } catch (e) { console.log("Schwurbler sound stop failed:", e); }
                                    }
                                }
                                
                                // Prevent audio overlap by stopping all special mode music
                                if (soundEnabled) {
                                    try {
                                        // Pause normal game music
                                        if (!music.paused) {
                                            music.pause();
                                        }
                                        if (!schwurblerMusic.paused) {
                                            schwurblerMusic.pause();
                                            schwurblerMusic.currentTime = 0;
                                        }
                                        if (!starSound.paused) {
                                            starSound.pause();
                                            starSound.currentTime = 0;
                                        }
                                    } catch (e) { console.log("Audio transition failed:", e); }
                                }
                                
                                // Reset consecutive star kills counter when ending star mode
                                if (powerUp.type === 'onyx' && starTimer > 0) {
                                    consecutiveStarKills = 0;
                                }
                            }
                            
                            switch (powerUp.type) {
                                case 'coin': 
                                    addPoints(10000);
                                    message = "+10.000";
                                    color = "#ffd700";
                                    break;
                                case 'star': 
                                    starTimer = 600; // 10 seconds at 60 FPS
                                    message = "STAR MODE";
                                    color = "#00ffff";
                                    
                                    // Spawn 7 extra planes when star mode begins (up to max 10 planes total)
                                    const extraPlanesToSpawn = Math.min(7, 10 - planes.length);
                                    console.log(`STAR MODE: Spawning ${extraPlanesToSpawn} extra planes`);
                                    
                                    // Spawn planes with a slight delay between each one
                                    for (let i = 0; i < extraPlanesToSpawn; i++) {
                                        setTimeout(() => {
                                            if (planes.length < 10) { // Double-check we're still under the limit
                                                const starPlane = new Plane();
                                                planes.push(starPlane);
                                                console.log(`STAR MODE: Extra plane ${i+1}/${extraPlanesToSpawn} spawned. Total planes: ${planes.length}`);
                                            }
                                        }, i * 200); // 200ms delay between each plane spawn
                                    }
                                    
                                    // Play star.mp3 during star mode
                                    if (soundEnabled) {
                                        // Play Star mode music
                                        playModeMusic('star');
                                    }
                                    
                                    // Enable cursor flashing effect
                                    cursorFlashing = true;
                                    flashOpacity = 0.5; // Start at 50% opacity
                                    flashDirection = -1; // Start by decreasing opacity
                                    
                                    // Remove cursor size upgrade logic - only keep flash effect
                                    break;
                                case 'onyx': 
                                    onyxTimer = 840;
                                    isInverted = true;
                                    message = "Schwurbler Mode!";
                                    color = "#ff00ff";
                                    if (soundEnabled) {
                                        // Play Onyx mode music
                                        playModeMusic('onyx');
                                    }
                                    break;
                                case 'schwab':
                                    schwabMode = true;
                                    schwabModeTimer = schwabModeMaxTime; // Set the timer (1 minute and 3 seconds)
                                    message = "Schwab Mode!";
                                    color = "#ff00ff";
                                    if (soundEnabled) {
                                        // Play Schwab mode music
                                        playModeMusic('schwab');
                                        
                                        // Set up event listener to play normal music when own.mp3 ends
                                        ownMusic.onended = function() {
                                            if (schwabMode && soundEnabled) {
                                                playModeMusic('normal');
                                            }
                                        };
                                    }
                                    break;
                            }
                            
                            // Use CenterMessage for power-ups
                            if (powerUp.type !== 'coin') {
                                messages.push(new CenterMessage(message, color, 35, 150));
                                // Update positions of all center messages
                                updateCenterMessagePositions();
                            } else {
                                // Use CenterMessage for coins as well (not Message at hit position)
                                messages.push(new CenterMessage(message, color, 35, 150));
                                // Update positions of all center messages
                                updateCenterMessagePositions();
                            }
                            updateScoreDisplay();
                            updateUpgrades();
                            collectibles.splice(i, 1);
                        }
                    }
                    
                    // Handle star mode plane killing ability
                    if (starTimer > 0) {
                        // During star mode, check if cursor is hovering over planes
                        for (let i = planes.length - 1; i >= 0; i--) {
                            const plane = planes[i];
                            const width = 75.3 * plane.sizeFactor;
                            const height = 32.1 * plane.sizeFactor;
                            
                            // Add a minimum hit area for very small planes to make them easier to hit
                            const minHitWidth = 40; // Minimum hit width in pixels
                            const minHitHeight = 20; // Minimum hit height in pixels
                            
                            // Use the larger of the actual size or minimum size for hit detection
                            const hitWidth = Math.max(width, minHitWidth);
                            const hitHeight = Math.max(height, minHitHeight);
                            
                            // Check if cursor is over the plane with the expanded hit area
                            if (mouseX >= plane.x - hitWidth/2 && mouseX <= plane.x + hitWidth/2 &&
                                mouseY >= plane.y - hitHeight/2 && mouseY <= plane.y + hitHeight/2) {
                                
                                // Create falling plane effect
                                plane.falling = true;
                                plane.fallingSpeed = 2;
                                plane.rotationSpeed = (Math.random() * 0.1) - 0.05;
                                plane.rotation = 0;
                                
                                // Remove from planes array
                                planes.splice(i, 1);
                                
                                // Add score
                                addPoints(2000);
                                updateScoreDisplay();
                                
                                // Create explosion effect
                                explosions.push(new Explosion(plane.x, plane.y, plane.sizeFactor * 1.5));
                                
                                // Play explosion sound
                                if (soundEnabled) {
                                    try { explosionSound.play(); } catch (e) { console.log("Explosion sound failed:", e); }
                                }
                                
                                // Add message for plane destruction during star mode
                                messages.push(new CenterMessage("Destroyed! +2000", "#ff4444", 30, 120));
                                updateCenterMessagePositions();
                            }
                        }
                    }

                    // Update and draw messages
                    for (let i = messages.length - 1; i >= 0; i--) {
                        const message = messages[i];
                        if (!message) {
                            console.log("Found undefined message at index:", i);
                            messages.splice(i, 1);
                            continue;
                        }
                        
                        message.update();
                        
                        // Remove messages that have expired
                        if (message.life <= 0) {
                            messages.splice(i, 1);
                            // When a message is removed, reposition all remaining center messages
                            if (message instanceof CenterMessage) {
                                updateCenterMessagePositions();
                            }
                            continue;
                        }
                        
                        // Ensure center messages are always drawn on top
                        if (message instanceof CenterMessage) {
                            // Draw with extra visibility
                            ctx.save();
                            ctx.globalAlpha = 1.0; // Force full opacity for center messages
                            if (typeof message.draw === 'function') {
                                message.draw();
                            } else {
                                console.log("Message missing draw method:", message);
                            }
                            ctx.restore();
                        } else {
                            message.draw();
                        }
                    }

                    for (let i = twinkleEffects.length - 1; i >= 0; i--) {
                        const twinkle = twinkleEffects[i];
                        twinkle.update();
                        twinkle.draw();
                        if (twinkle.life <= 0) twinkleEffects.splice(i, 1);
                    }

                    if (onyxTimer > 0) {
                        onyxTimer--;
                        if (onyxTimer === 0) {
                            isInverted = false;
                            
                            // Switch to appropriate music based on active modes
                            if (soundEnabled) {
                                if (schwabMode) {
                                    playModeMusic('schwab');
                                } else if (starTimer > 0) {
                                    playModeMusic('star');
                                } else if (deathMode) {
                                    playModeMusic('death');
                                } else {
                                    playModeMusic('normal');
                                }
                            }
                        }
                    }
                    
                    // Handle Death Mode timer
                    if (deathModeTimer > 0) {
                        deathModeTimer--;
                        
                        // Debug message every second
                        if (deathModeTimer % 60 === 0) {
                            console.log(`Death Mode: ${deathModeTimer/60} seconds remaining, ${deathModeSpawnCount} planes spawned so far`);
                        }
                        
                        // Spawn NPC planes during Death Mode
                        if (deathMode && deathModeSpawnCount < 40) {
                            // Calculate how many planes to spawn per frame to reach 40 planes in 15 seconds
                            // 15 seconds = 900 frames at 60fps, so we need to spawn a plane every 22.5 frames
                            if (gameTime % 23 === 0) { // Using 23 as an integer approximation of 22.5
                                try {
                                    // Create an NPC plane using the dedicated function
                                    const plane = createNPCPlane();
                                    
                                    // Add to planes array
                                    planes.push(plane);
                                    deathModeSpawnCount++;
                                    console.log(`DEATH MODE: NPC plane spawned (${deathModeSpawnCount}/40). Total planes: ${planes.length}`);
                                    
                                    // Force a small message to show spawning is working
                                    if (deathModeSpawnCount % 5 === 0) {
                                        messages.push(new Message(`NPC #${deathModeSpawnCount}`, plane.x, plane.y, '#ff0000'));
                                    }
                                } catch (e) {
                                    console.error("Error spawning NPC plane in Death Mode:", e);
                                }
                            }
                        }
                        
                        // When Death Mode expires
                        if (deathModeTimer === 0) {
                            deathMode = false;
                            deathModeSpawnCount = 0;
                            messages.push(new CenterMessage("DEATH MODE ENDED", '#ff0000', 35, 180));
                            
                            // Switch to appropriate music based on active modes
                            if (soundEnabled) {
                                if (starTimer > 0) {
                                    playModeMusic('star');
                                } else if (onyxTimer > 0) {
                                    playModeMusic('onyx');
                                } else if (schwabMode) {
                                    playModeMusic('schwab');
                                } else {
                                    playModeMusic('normal');
                                }
                            }
                        }
                    }

                    if (starTimer > 0) {
                        starTimer--;
                        // When star power-up expires
                        if (starTimer === 0) {
                            // Reset cursor flashing effect
                            cursorFlashing = false;
                            // Reset consecutive plane kills counter
                            consecutiveStarKills = 0;
                            
                            // Switch to appropriate music based on active modes
                            if (soundEnabled) {
                                if (onyxTimer > 0) {
                                    playModeMusic('onyx');
                                } else if (schwabMode) {
                                    playModeMusic('schwab');
                                } else if (deathMode) {
                                    playModeMusic('death');
                                } else {
                                    playModeMusic('normal');
                                }
                            }
                        }
                    }

                    // Handle Schwab mode timer
                    if (schwabModeTimer > 0) {
                        schwabModeTimer--;
                        // When Schwab mode expires
                        if (schwabModeTimer === 0) {
                            schwabMode = false;
                            // Removed "Schwab mode ended" message as requested
                            
                            // Stop own.mp3 if it's still playing and switch to normal music
                            if (soundEnabled && currentModeMusic === ownMusic) {
                                playModeMusic('normal');
                            }
                        }
                    }
                    
                    // Check for special trail bonuses (repto and rainbow)
                    checkSpecialTrailBonus();

                    if (shotCooldown > 0) shotCooldown--;

                    if (isInverted) {
                        ctx.save();
                        ctx.font = `${canvas.width / 5}px Impact`; // Changed from 2.5 to 5 to make text 50% smaller
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.textAlign = 'left';
                        const text = 'DAMN IT FEELS GOOD TO BE A SCHWURBLER';
                        ctx.fillText(text, onyxTextX, canvas.height * 0.75);
                        onyxTextX -= 7.5;
                        if (onyxTextX < -ctx.measureText(text).width) onyxTextX = canvas.width;
                        ctx.restore();
                    }

                    gameTime++;
                    
                    // Power-up spawning logic - consistent throughout the game
                    if (gameTime - lastPowerupTime >= MIN_POWERUP_INTERVAL) {
                        // Base chance increases the longer it's been since a power-up spawned
                        const timeMultiplier = Math.min(3, 1 + (gameTime - lastPowerupTime - MIN_POWERUP_INTERVAL) / 1800);
                        // Increased base chance for more frequent power-ups
                        const spawnChance = BASE_POWERUP_CHANCE * 2 * timeMultiplier;
                        
                        if (Math.random() < spawnChance) {
                            const x = Math.random() * canvas.width;
                            const y = Math.random() * canvas.height * 0.7; // Keep power-ups in the upper 70% of the screen
                            
                            // Determine which type of power-up to spawn
                            const rand = Math.random();
                            
                            // Special case: Guarantee an Onyx power-up after 30 seconds if none has appeared yet
                            if (!onyxTimer && gameTime > 1800 && rand < 0.15) {
                                collectibles.push(new OnyxPowerUp(x, y));
                                console.log("Spawned Onyx power-up at", x, y);
                            } 
                            // More Star power-ups when the player has more score
                            else if (rand < 0.3 + (score > 50000 ? 0.1 : 0)) {
                                collectibles.push(new StarPowerUp(x, y));
                                console.log("Spawned Star power-up at", x, y);
                            } 
                            // Coins are most common
                            else {
                                collectibles.push(new CoinPowerUp(x, y));
                                console.log("Spawned Coin power-up at", x, y);
                            }
                            
                            // Reset the timer
                            lastPowerupTime = gameTime;
                        }
                    }

                    // Dynamic plane spawning logic based on game time
                    if (gameTime >= nextPlaneSpawn) {
                        // Don't spawn regular planes during Death Mode
                        if (!deathMode) {
                            // Calculate the spawn interval based on game progress
                            const spawnInterval = getPlaneSpawnInterval();
                            
                            // Check slow mode - if active, only spawn planes 10% of the time (90% reduction)
                            if (!slowMode || (slowMode && Math.random() < 0.1)) {
                                const newPlane = new Plane();
                                planes.push(newPlane);
                                console.log(`Plane spawned! Total planes: ${planes.length}, Interval: ${spawnInterval}${slowMode ? " (SLOW MODE)" : ""}${starTimer > 0 ? " (STAR MODE)" : ""}`);
                            } else {
                                console.log(`Plane spawn skipped due to SLOW MODE. Current interval: ${spawnInterval}`);
                            }
                            
                            // Set the next spawn time
                            nextPlaneSpawn = gameTime + spawnInterval;
                        }
                    } else if (planes.length >= CONFIG.PERFORMANCE.MAX_PLANES && gameTime % 60 === 0) {
                        // Log when we're at max planes, but only once per second to avoid spam
                        console.log(`Maximum planes reached (${planes.length}/${CONFIG.PERFORMANCE.MAX_PLANES}). Skipping spawn.`);
                    }
                    
                    // Star mode now spawns 7 planes at activation instead of random bonus planes
                    
                    let totalTrailLength = chemtrails.reduce((sum, t) => sum + Math.hypot(t.x2 - t.x1, t.y2 - t.y1), 0);
                    if ((totalTrailLength * 3) / (canvas.width * canvas.height) > 0.09) { // Changed from 0.11 to 0.09 (9%)
                        // Capture the current frame before showing game over screen
                        lastFrameImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        gameOver = true;
                        // Show organic points only (total points minus cheat points)
                        const organicPoints = totalScore - cheatPoints;
                        gameOverText.innerHTML = `<h1>GAME OVER</h1><p class="points">Total Points: ${organicPoints}</p><p class="message">Deutschland ist komplett verseucht<br>und DU allein bist Schuld!</p>`;
                        gameOverDiv.style.display = 'flex';
                        
                        // Stop alarm sound when game is over
                        if (!alarmSound.paused) {
                            alarmSound.pause();
                            alarmSound.currentTime = 0;
                        }
                        
                        // Update high score if needed (using organic points)
                        if (organicPoints > highScore) {
                            highScore = organicPoints;
                            localStorage.setItem('highScore', highScore);
                        }
                        
                        // Instead of clearing all visual elements, add a blur effect to the canvas
                        // This creates a freeze frame effect where the last game state is visible but blurred
                        canvas.style.filter = 'blur(5px)';
                        
                        // Don't clear planes and chemtrails - keep them visible behind the end screen
                        // But clear active elements that would continue to play sounds or create new effects
                        particles = [];
                        collectibles = [];
                        twinkleEffects = [];
                        shots = [];
                        explosions = [];
                        
                        try { 
                            // Stop any currently playing music
                            if (music && !music.paused) music.pause();
                            if (schwurblerMusic && !schwurblerMusic.paused) schwurblerMusic.pause();
                            if (starSound && !starSound.paused) starSound.pause();
                            if (ownMusic && !ownMusic.paused) ownMusic.pause();
                            
                            // Play game over music using the music management system
                            if (soundEnabled) {
                                playModeMusic('gameover');
                            }
                        } catch (e) { console.log("Game over audio failed:", e); }
                    }
                }

                ctx.fillStyle = invertColor('#666');
                cityFar.forEach(b => {
                    // Only update position if game is not over
                    if (!gameOver) {
                        b.x -= 0.25;
                        if (b.x + b.width < 0) b.x = canvas.width;
                    }
                    if (b.x < canvas.width) ctx.fillRect(b.x, canvas.height - b.height, b.width, b.height);
                });
                ctx.fillStyle = invertColor('#333');
                cityMid.forEach(b => {
                    // Only update position if game is not over
                    if (!gameOver) {
                        b.x -= 0.5;
                        if (b.x + b.width < 0) b.x = canvas.width;
                    }
                    if (b.x < canvas.width) ctx.fillRect(b.x, canvas.height - b.height, b.width, b.height);
                });
                ctx.fillStyle = invertColor('#000');
                cityFront.forEach(b => {
                    // Only update position if game is not over
                    if (!gameOver) {
                        b.x -= 1;
                        if (b.x + b.width < 0) b.x = canvas.width;
                    }
                    if (b.x < canvas.width) ctx.fillRect(b.x, canvas.height - b.height, b.width, b.height);
                });

                // Draw a semi-transparent gradient at the top of the screen (50% black to transparent)
                // This will be behind UI elements but above the sky, planes, and trails
                const topGradientHeight = 100; // 100px height as requested
                const topGradient = ctx.createLinearGradient(0, 0, 0, topGradientHeight);
                topGradient.addColorStop(0, 'rgba(0, 0, 0, 0.5)'); // 50% black at the top
                topGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // Fully transparent at the bottom
                
                // Fill the gradient rectangle
                ctx.fillStyle = topGradient;
                ctx.fillRect(0, 0, canvas.width, topGradientHeight);

                if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height && !gameOver) {
                    const size = cursorSizes[sizeLevel];
                    ctx.save();
                    if (((targetMode && targetPlane) || targetRemaining) && starTimer <= 0 && !venomMode) {
                        // Only show target graphic when NOT in star mode or venom mode
                        const targetSize = size * 1.5;
                        
                        // Use the drawn crosshair target instead of the image
                        if (isInverted) {
                            // In onyx mode, use cyan (inverted red) for the crosshair
                            ctx.strokeStyle = '#00ffff';
                        } else {
                            // In normal mode, use red
                            ctx.strokeStyle = '#ff0000';
                        }
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(mouseX, mouseY, targetSize / 3, 0, Math.PI * 2);
                        ctx.moveTo(mouseX - targetSize / 2, mouseY);
                        ctx.lineTo(mouseX + targetSize / 2, mouseY);
                        ctx.moveTo(mouseX, mouseY - targetSize / 2);
                        ctx.lineTo(mouseX, mouseY + targetSize / 2);
                        ctx.stroke();
                    } else {
                        const img = cursorImgs[styleLevel]; // Changed from sizeLevel to styleLevel
                        if (img.complete && img.naturalWidth) {
                            // Apply brightness filter during star power-up flash effect
                            if (cursorFlashing && starTimer > 0) {
                                ctx.save();
                                
                                // Calculate brightness value for the flash effect (100% to 200%)
                                const brightnessPercent = 100 + Math.floor(flashOpacity * 200);
                                
                                // Apply brightness filter directly to the image
                                ctx.filter = `brightness(${brightnessPercent}%)`;
                                
                                // Draw the image with the filter applied
                                ctx.drawImage(img, mouseX - size / 2, mouseY - size / 2, size, size);
                                
                                // Reset the context
                                ctx.restore();
                                
                                // Oscillate opacity between 0.2 and 0.5 for the brightness calculation
                                flashOpacity += 0.02 * flashDirection;
                                if (flashOpacity <= 0.2) {
                                    flashOpacity = 0.2;
                                    flashDirection = 1;
                                } else if (flashOpacity >= 0.5) {
                                    flashOpacity = 0.5;
                                    flashDirection = -1;
                                }
                            } else {
                                // Normal drawing without flash effect
                                ctx.drawImage(img, mouseX - size / 2, mouseY - size / 2, size, size);
                            }
                        } else {
                            // Fallback rectangle cursor
                            ctx.fillStyle = invertColor(cursorColors[styleLevel]);
                            
                            // Apply brightness filter for rectangle cursor during star mode
                            if (cursorFlashing && starTimer > 0) {
                                ctx.save();
                                const brightnessPercent = 100 + Math.floor(flashOpacity * 200);
                                ctx.filter = `brightness(${brightnessPercent}%)`;
                                ctx.fillRect(mouseX - size / 2, mouseY - size / 2, size, size);
                                ctx.restore();
                                
                                // Oscillate opacity for brightness calculation
                                flashOpacity += 0.02 * flashDirection;
                                if (flashOpacity <= 0.2) {
                                    flashOpacity = 0.2;
                                    flashDirection = 1;
                                } else if (flashOpacity >= 0.5) {
                                    flashOpacity = 0.5;
                                    flashDirection = -1;
                                }
                            } else {
                                // Normal drawing without flash effect
                                ctx.fillRect(mouseX - size / 2, mouseY - size / 2, size, size);
                            }
                        }
                    }
                    ctx.restore();
                }
            } catch (e) {
                console.error("Error in game loop:", e);
            }

            requestAnimationFrame(animate);
        }

        function pointLineDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const numerator = ((px - x1) * dx + (py - y1) * dy);
            const denominator = (dx * dx + dy * dy);
            const t = Math.max(0, Math.min(1, numerator / denominator));
            const closestX = x1 + t * dx;
            const closestY = y1 + t * dy;
            return Math.hypot(px - closestX, py - closestY);
        }
        
        // New function to detect and clean small isolated trail fragments
        function cleanTrailFragments(mouseX, mouseY, baseCleanupDistance) {
            // Create a map to track connected trail segments
            const trailConnections = new Map();
            
            // First pass: build connection map
            for (let i = 0; i < chemtrails.length; i++) {
                const trail = chemtrails[i];
                
                // Skip if this trail is already being cleaned by the cursor
                const dist = pointLineDistance(mouseX, mouseY, trail.x1, trail.y1, trail.x2, trail.y2);
                if (dist < baseCleanupDistance) continue;
                
                // Add trail endpoints to the connection map
                const startKey = `${Math.round(trail.x1)},${Math.round(trail.y1)}`;
                const endKey = `${Math.round(trail.x2)},${Math.round(trail.y2)}`;
                
                if (!trailConnections.has(startKey)) {
                    trailConnections.set(startKey, { count: 0, trails: [] });
                }
                if (!trailConnections.has(endKey)) {
                    trailConnections.set(endKey, { count: 0, trails: [] });
                }
                
                trailConnections.get(startKey).count++;
                trailConnections.get(startKey).trails.push(i);
                trailConnections.get(endKey).count++;
                trailConnections.get(endKey).trails.push(i);
            }
            
            // Second pass: identify isolated fragments
            const fragmentsToRemove = new Set();
            
            for (let i = 0; i < chemtrails.length; i++) {
                if (fragmentsToRemove.has(i)) continue;
                
                const trail = chemtrails[i];
                
                // Skip if this trail is already being cleaned by the cursor
                const dist = pointLineDistance(mouseX, mouseY, trail.x1, trail.y1, trail.x2, trail.y2);
                if (dist < baseCleanupDistance) continue;
                
                // Check if this is a small fragment
                const trailLength = Math.hypot(trail.x2 - trail.x1, trail.y2 - trail.y1);
                
                // If it's a small trail segment and near the cursor's extended range
                const extendedCleanupDistance = baseCleanupDistance * 1.8; // 80% larger cleaning radius for fragments
                const isSmallFragment = trailLength < 30; // Consider segments less than 30px as small fragments
                
                if (isSmallFragment && dist < extendedCleanupDistance) {
                    fragmentsToRemove.add(i);
                    
                    // Create a subtle particle effect for the fragment
                    particles.push(new Particle(trail.x1, trail.y1));
                    particles.push(new Particle(trail.x2, trail.y2));
                    
                    // Add points for the fragment (half the normal points)
                    const rawPoints = Math.round(trailLength * 0.5);
                    if (window.trailPointsAccumulator === undefined) {
                        window.trailPointsAccumulator = 0;
                    }
                    window.trailPointsAccumulator += rawPoints;
                }
                
                // Check for dangling segments (connected to only one other segment)
                const startKey = `${Math.round(trail.x1)},${Math.round(trail.y1)}`;
                const endKey = `${Math.round(trail.x2)},${Math.round(trail.y2)}`;
                
                const isStartDangling = trailConnections.get(startKey).count === 1;
                const isEndDangling = trailConnections.get(endKey).count === 1;
                
                // If both ends are dangling and it's within extended range, it's an isolated segment
                if (isStartDangling && isEndDangling && dist < extendedCleanupDistance * 1.2) {
                    fragmentsToRemove.add(i);
                    
                    // Remove particle creation for fragments to eliminate unwanted cursor effects
                    // This keeps only the original particle effect directly on the trails
                    
                    // Add points for the fragment (half the normal points)
                    const rawPoints = Math.round(trailLength * 0.5);
                    if (window.trailPointsAccumulator === undefined) {
                        window.trailPointsAccumulator = 0;
                    }
                    window.trailPointsAccumulator += rawPoints;
                }
            }
            
            // Remove the identified fragments
            if (fragmentsToRemove.size > 0) {
                // Convert Set to Array and sort in descending order to avoid index shifting issues
                const indicesToRemove = Array.from(fragmentsToRemove).sort((a, b) => b - a);
                
                for (const index of indicesToRemove) {
                    chemtrails.splice(index, 1);
                }
                
                return indicesToRemove.length; // Return number of fragments removed
            }
            
            return 0;
        }
        
        function waitForAssets(callback) {
            const assets = [planeImg, planerImg, schwabImg, cloudImgs[0], cloudImgs[1], ...cursorImgs, ...explosionFrames];
            let loaded = 0;
            const total = assets.length;

            function checkLoaded() {
                loaded++;
                if (loaded === total) {
                    console.log("All assets loaded, starting game loop...");
                    callback();
                }
            }

            assets.forEach(img => {
                if (img.complete && img.naturalWidth) {
                    checkLoaded();
                } else {
                    img.onload = checkLoaded;
                    img.onerror = () => {
                        console.warn(`Failed to load ${img.src}, proceeding with placeholder`);
                        checkLoaded();
                    };
                }
            });
        }

        canvas.style.cursor = 'none';
        console.log("Grok's Chemtrail Madness - Initializing...");
        waitForAssets(() => {
            console.log("Grok's Chemtrail Madness - Ready to soar!");
            animate();
        });

        // Add a debug function to check if messages are being processed
        function debugMessages() {
            console.log("Current messages:", messages.length);
            console.log("Combo count:", comboCount);
            console.log("Sky clean shown:", skyCleanMessageShown);
            console.log("Chemtrails count:", chemtrails.length);
            console.log("Game has started:", gameHasStarted);
            console.log("Game time:", gameTime);
            
            // Test font rendering with a temporary message
            const testMsg = new CenterMessage("TEST MESSAGE", '#ffffff', 40, 180);
            messages.push(testMsg);
            console.log("Added test message");
            
            // Try with Arial font as a fallback test
            setTimeout(() => {
                const arialMsg = new CenterMessage("ARIAL TEST", '#ff0000', 40, 180);
                messages.push(arialMsg);
                console.log("Added Arial test message");
            }, 1000);
        }

        // Add a font loading check
        document.fonts.ready.then(() => {
            console.log("Fonts loaded:");
            document.fonts.forEach(font => {
                console.log(`- ${font.family} (${font.loaded ? 'loaded' : 'not loaded'})`);
            });
            
            // Test if Visitor font is available
            if (document.fonts.check('1em "Visitor"')) {
                console.log("Visitor font is available!");
            } else {
                console.log("Visitor font is NOT available! Using fallbacks.");
            }
        });

        // Keyboard controls for the game
        document.addEventListener('keydown', (e) => {
            // Only process if game is started and not over
            if (!gameStarted || gameOver) return;
            
            // Space = fire
            if (e.code === 'Space' && !e.repeat) {
                fireShot();
            }
        });

        // Function to update vertical positioning of center messages
        function updateCenterMessagePositions() {
            // Filter only center messages and sort by creation time (newest first)
            const centerMessages = messages.filter(msg => msg instanceof CenterMessage)
                                           .sort((a, b) => b.creationTime - a.creationTime);
            
            if (centerMessages.length > 0) {
                // Start positioning from the center of the screen
                let currentY = canvas.height / 2;
                
                // Position each message with adequate spacing
                for (let i = 0; i < centerMessages.length; i++) {
                    const message = centerMessages[i];
                    
                    // First message (newest) goes at center
                    if (i === 0) {
                        message.y = currentY;
                    } else {
                        // Move position up for each older message
                        // Use consistent spacing of 40px between messages
                        currentY -= 40;
                        message.y = currentY;
                    }
                }
            }
        }
        
        // Helper function to add a center message without duplicates
        function addCenterMessage(text, color = '#ffffff', size = 30, duration = 120) {
            console.log("addCenterMessage called:", text); // Debug log
            
            // Format bonus point messages with a period as the thousands separator
            if (text.startsWith('+') && !isNaN(parseInt(text.replace(/\D/g, '')))) {
                // Extract the number from the text
                const pointValue = parseInt(text.replace(/\D/g, ''));
                // Format with a period as the thousands separator
                text = `+${pointValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`;
            }
            
            // Check if a message with the same text already exists
            const existingMessage = messages.find(msg => 
                msg instanceof CenterMessage && msg.text === text.toUpperCase()
            );
            
            // If the message already exists, refresh its life instead of adding a new one
            if (existingMessage) {
                console.log("Message already exists, refreshing life:", text);
                existingMessage.life = Math.max(existingMessage.life, duration);
                return;
            }
            
            // Add new message
            const message = new CenterMessage(text, color, size, duration);
            messages.push(message);
            console.log("New message added to messages array. Current count:", messages.length);
            
            // Update positions whenever a new message is added
            updateCenterMessagePositions();
        }
        
        // Initialize some clouds
        for (let i = 0; i < 15; i++) {
            clouds.push(new Cloud());
        }

        // Check for all special trails cleared
        if (reptoTrailsExist) {
            // Count active repto trails
            const reptoTrails = chemtrails.filter(t => t.trailType === 'repto');
            reptoTrailsCount = reptoTrails.length;
            
            // If no more repto trails, update the flag
            if (reptoTrailsCount <= 0) {
                reptoTrailsExist = false;
                // No global bonus for clearing all repto trails - bonuses are per-plane only
            }
        }

        if (rainbowTrailsExist) {
            // Count active rainbow trails
            const rainbowTrails = chemtrails.filter(t => t.trailType === 'rainbow');
            rainbowTrailsCount = rainbowTrails.length;
            
            // If no more rainbow trails, update the flag
            if (rainbowTrailsCount <= 0) {
                rainbowTrailsExist = false;
                // No global bonus for clearing all rainbow trails - bonuses are per-plane only
            }
        }

        planes.forEach(plane => {
            // ... existing code ...
        });

        // Initialize performance toggle button state
        if (perfLoggingEnabled) {
            perfToggle.classList.add('active');
            perfToggle.textContent = 'Perf Monitor: ON';
        } else {
            perfToggle.classList.remove('active');
            perfToggle.textContent = 'Perf Monitor: OFF';
        }

        // Performance monitoring toggle
        perfToggle.addEventListener('click', () => {
            perfLoggingEnabled = !perfLoggingEnabled;
            perfToggle.textContent = `Perf Monitor: ${perfLoggingEnabled ? 'ON' : 'OFF'}`;
            console.log(`Performance monitoring ${perfLoggingEnabled ? 'enabled' : 'disabled'}`);
            
            // Toggle active class for styling
            if (perfLoggingEnabled) {
                perfToggle.classList.add('active');
                frameTimes = [];
                slowFramesCount = 0;
                lastFrameTime = performance.now();
            } else {
                perfToggle.classList.remove('active');
            }
        });

        // Check for plane hover (target mode)
        if (shootLevel > 0 && !targetMode && !venomMode) { // Don't activate target mode in Venom mode
            for (let i = 0; i < planes.length; i++) {
                const plane = planes[i];
                const dist = Math.hypot(mouseX - plane.x, mouseY - plane.y);
                
                // Enhance hitbox for small and medium planes at the highest size levels
                let effectiveHitboxSize = plane.width / 2;
                
                // Make small planes easier to hit, especially with larger cursors
                // Apply hitbox enhancement starting from size level 2 instead of 4
                if (sizeLevel >= 2 && plane.sizeFactor < 2.5) {
                    // Scale the hitbox enhancement based on cursor size level
                    const sizeBoost = 1 + (sizeLevel * 0.15); // Increases with cursor size
                    
                    // Small planes (sizeFactor < 0.5) get a bigger boost than medium planes
                    if (plane.sizeFactor < 0.5) {
                        // Increase from 0.9 to 1.2 (120% larger hitbox for small planes)
                        effectiveHitboxSize = plane.width * (0.9 * sizeBoost);
                    } else {
                        // Increase from 0.7 to 0.9 (80% larger hitbox for medium planes)
                        effectiveHitboxSize = plane.width * (0.7 * sizeBoost);
                    }
                }
                
                if (dist < effectiveHitboxSize + cursorSizes[sizeLevel] / 2) {
                    targetMode = true;
                    targetPlane = plane;
                    break;
                }
            }
        }
        
        // Reset target mode if no plane is close enough or in Venom mode
        if ((targetMode && !venomMode) && targetPlane) {
            const dist = Math.hypot(mouseX - targetPlane.x, mouseY - targetPlane.y);
            
            // Also enhance the detection for maintaining lock on the target
            let effectiveHitboxSize = targetPlane.width / 2;
            
            // Apply the same hitbox enhancement when maintaining target lock
            if (sizeLevel >= 2 && targetPlane.sizeFactor < 2.5) {
                // Scale the hitbox enhancement based on cursor size level
                const sizeBoost = 1 + (sizeLevel * 0.15); // Increases with cursor size
                
                // Small planes (sizeFactor < 0.5) get a bigger boost than medium planes
                if (targetPlane.sizeFactor < 0.5) {
                    // Increase from 0.9 to 1.2 (120% larger hitbox for small planes)
                    effectiveHitboxSize = targetPlane.width * (0.9 * sizeBoost);
                } else {
                    // Increase from 0.7 to 0.9 (80% larger hitbox for medium planes)
                    effectiveHitboxSize = targetPlane.width * (0.7 * sizeBoost);
                }
            }
            
            // Use the enhanced hitbox size for maintaining target lock
            if (dist > effectiveHitboxSize + cursorSizes[sizeLevel] / 2) {
                targetMode = false;
                targetPlane = null;
            }
        } else if (venomMode) {
            // Always disable target mode in Venom mode
            targetMode = false;
            targetPlane = null;
        }
        
        // Draw cursor
        if (((targetMode && targetPlane) || targetRemaining) && starTimer <= 0 && !venomMode) {
            // Draw target cursor (only when not in Venom mode)
            const targetSize = cursorSizes[sizeLevel] * 1.5;
            
            // Use the drawn crosshair target instead of the image
            if (isInverted) {
                // In onyx mode, use cyan (inverted red) for the crosshair
                ctx.strokeStyle = '#00ffff';
            } else {
                // In normal mode, use red
                ctx.strokeStyle = '#ff0000';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, targetSize / 3, 0, Math.PI * 2);
            ctx.moveTo(mouseX - targetSize / 2, mouseY);
            ctx.lineTo(mouseX + targetSize / 2, mouseY);
            ctx.moveTo(mouseX, mouseY - targetSize / 2);
            ctx.lineTo(mouseX, mouseY + targetSize / 2);
            if (soundEnabled) {
                try {
                    music.pause();
                    music.currentTime = 0;
                    skyMusic.pause();
                    skyMusic.currentTime = 0;
                    // Play game over music
                    playModeMusic('gameover');
                } catch (e) { console.log("Music stop failed:", e); }
            }
            
            console.log("GAME OVER triggered at density: " + (chemtrailDensity * 100).toFixed(1) + "%");
        }

        // Add a helper function to play music
        function playMusic(musicTrack) {
            if (!soundEnabled) return;
            
            // Pause all other music tracks first
            music.pause();
            schwurblerMusic.pause();
            starSound.pause();
            ownMusic.pause();
            
            // Play the requested track
            try {
                musicTrack.currentTime = 0;
                musicTrack.play();
            } catch (e) {
                console.log("Failed to play music track:", e);
            }
        }

        // Function to get color for star mode multiplier messages
        function getStarModeMultiplierColor(multiplier) {
            if (multiplier % 2 === 1) return "#FFEB3B"; // Light yellow for odd multipliers
            return "#FFC107"; // Darker yellow for even multipliers
        }

        // Array to track recent messages for random props sound
        let mouseClicked = false; // Flag to track individual mouse clicks for the first shooting level

        // Function to destroy the targeted plane (for one-shot kills)
        function destroyTargetPlane() {
            if (!targetPlane) return;
            
            try {
                // Store the position of the exploding target
                targetPosition.x = targetPlane.x;
                targetPosition.y = targetPlane.y;
                
                // Set flag to keep target cursor visible during explosion
                targetRemaining = true;
                
                // Mark all chemtrails from this plane as having an inactive plane
                chemtrails.forEach(trail => {
                    if (trail.planeId === targetPlane.id) {
                        trail.planeActive = false;
                    }
                });
                
                // Only create falling plane effect in star mode
                if (starTimer > 0) {
                    fallingPlanes.push(new FallingPlane(targetPlane));
                }
                
                // Create explosion
                explosions.push(new Explosion(targetPlane.x, targetPlane.y, targetPlane.sizeFactor));
                if (soundEnabled) {
                    try { explodeSound.play(); } catch (e) { console.log("Explode sound failed:", e); }
                }
                
                // Add score based on plane type and size
                const planeScore = targetPlane.points * 100;
                addPoints(planeScore);
                updateScoreDisplay();
                
                // Add a message for the points scored
                messages.push(new Message(`+${planeScore}`, targetPlane.x, targetPlane.y, '#ffffff', 24, 60)); // Increased size from 16 to 24 (1.5x bigger)
                updateMessagePositions();
                
                // Find the plane in the array and remove it
                const planeIndex = planes.findIndex(p => p.id === targetPlane.id);
                if (planeIndex !== -1) {
                    planes.splice(planeIndex, 1);
                }
                
                // Reset target after destroying plane
                targetMode = false;
                targetPlane = null;
            } catch (e) {
                console.error("Error destroying plane:", e);
            }
        }

        // Add event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // TESTING: Add debug key to force clean sky event
        document.addEventListener('keydown', function(e) {
            // Shift+1 key to force clean sky event (changed from F9)
            if (e.key === '1' && e.shiftKey && gameStarted && !gameOver) {
                console.log("DEBUG: Forcing clean sky event via Shift+1 key");
                
                // Force clean sky event
                chemtrails = []; // Clear all chemtrails
                
                // Force a new center message for clean sky with high visibility
                const skyMsg = new CenterMessage("THE SKY IS CLEAN!", '#ffffff', 50, 240);
                messages.push(skyMsg);
                console.log("Added sky clean message to messages array (forced via Shift+1)");
                
                // Force immediate display of the message
                skyMsg.draw();
                
                skyCleanMessageShown = true;
                
                // Add bonus points for clean sky
                const cleanSkyBonus = 5000; // Increased bonus for cleaning the sky
                addPoints(cleanSkyBonus);
                updateScoreDisplay();
                
                // Add another message for the bonus points
                messages.push(new CenterMessage(`+${cleanSkyBonus} POINTS`, '#ffff00', 35, 180));
                
                // Play the clean sky music
                if (soundEnabled) {
                    playModeMusic('clean');
                }
            }
        });
        
        // Initialize sound effects
        window.addEventListener('load', function() {
            console.log("Window loaded, initializing sound effects");
            
            // Function to play hover sound
            function playHoverSound() {
                if (soundEnabled) {
                    const sound = new Audio('./assets/hover.mp3');
                    sound.volume = 0.5;
                    sound.play().catch(e => console.log("Hover sound error:", e));
                }
            }
            
            // Function to play click sound
            function playClickSound() {
                if (soundEnabled) {
                    const sound = new Audio('./assets/click.mp3');
                    sound.volume = 0.6;
                    sound.play().catch(e => console.log("Click sound error:", e));
                }
            }
            
            // Add hover and click sounds to all product links on start screen
            document.querySelectorAll('#start-products .product-link').forEach(link => {
                link.addEventListener('mouseenter', playHoverSound);
                link.addEventListener('click', playClickSound);
            });
            
            // Add hover and click sounds to game logo
            const gameLogo = document.getElementById('game-logo');
            if (gameLogo) {
                gameLogo.addEventListener('mouseenter', playHoverSound);
                gameLogo.addEventListener('click', playClickSound);
            }
            
            // Add hover and click sounds to start button
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.addEventListener('mouseenter', playHoverSound);
                startBtn.addEventListener('click', playClickSound);
            }
            
            // Add hover and click sounds to all product links on game over screen
            document.querySelectorAll('#bottom-products .product-link').forEach(link => {
                link.addEventListener('mouseenter', playHoverSound);
                link.addEventListener('click', playClickSound);
            });
            
            // Add hover and click sounds to Willy ad
            const willyAd = document.getElementById('willy-ad');
            if (willyAd) {
                willyAd.addEventListener('mouseenter', playHoverSound);
                willyAd.addEventListener('click', playClickSound);
            }
            
            // Add hover and click sounds to play again button
            const playAgainBtn = document.getElementById('play-again-btn');
            if (playAgainBtn) {
                playAgainBtn.addEventListener('mouseenter', playHoverSound);
                playAgainBtn.addEventListener('click', playClickSound);
            }
            
            // Add hover and click sounds to upgrade buttons
            document.querySelectorAll('.upgrade-btn').forEach(button => {
                button.addEventListener('mouseenter', function() {
                    if (this.classList.contains('active')) {
                        playHoverSound();
                    }
                });
                button.addEventListener('click', function() {
                    if (this.classList.contains('active')) {
                        playClickSound();
                    }
                });
            });
            
            // Test sound on load
            setTimeout(() => {
                console.log("Testing hover sound...");
                playHoverSound();
            }, 1000);
            
            console.log("Sound effects initialized for all interactive elements");
        });

        // Handle key down events

        // Add a function to create NPC planes for Death Mode
        function createNPCPlane() {
            try {
                // Create a basic plane first with random position
                const plane = new Plane();
                
                // Override with NPC plane properties
                plane.planeTypeId = 'npc';
                plane.type = 'normal';
                plane.sizeFactor = 0.6 + Math.random() * 0.3; // Between 0.6 and 0.9
                plane.lineWidth = 5;
                plane.points = 25;
                plane.opacity = 1.0; // Full opacity for maximum visibility
                plane.trailType = 'npc';
                plane.trailMultiplier = 1.5;
                plane.trailMessage = "NPC PLANE BONUS";
                
                // Set fixed speed of 3.0
                if (plane.isCurved) {
                    plane.tIncrement = 3.0;
                } else {
                    const angle = Math.atan2(plane.dy, plane.dx);
                    const speed = 3.0;
                    plane.dx = speed * Math.cos(angle);
                    plane.dy = speed * Math.sin(angle);
                }
                
                // Register this plane as having a special trail
                specialTrailPlanes[plane.id] = {
                    trailType: plane.trailType,
                    trailMessage: plane.trailMessage
                };
                
                console.log("Created NPC plane:", plane);
                return plane;
            } catch (e) {
                console.error("Error in createNPCPlane:", e);
                
                // Create a fallback plane with minimal properties if there's an error
                const fallbackPlane = {
                    id: 'npc_fallback_' + Date.now(),
                    planeTypeId: 'npc',
                    x: Math.random() * canvas.width,
                    y: -50,
                    dx: 0,
                    dy: 3.0,
                    sizeFactor: 0.8,
                    lineWidth: 5,
                    opacity: 1.0,
                    isCurved: false,
                    trailType: 'npc',
                    trailMultiplier: 1.5,
                    trailMessage: "NPC PLANE BONUS",
                    lastTrail: { x: 0, y: 0 },
                    update: function() {
                        this.y += this.dy;
                        this.lastTrail = { x: this.x, y: this.y };
                        return this.y < canvas.height + 100;
                    },
                    draw: function() {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.drawImage(npcPlaneImg, -30, -15, 60, 30);
                        ctx.restore();
                    }
                };
                
                // Register this fallback plane as having a special trail
                specialTrailPlanes[fallbackPlane.id] = {
                    trailType: fallbackPlane.trailType,
                    trailMessage: fallbackPlane.trailMessage
                };
                
                console.log("Created fallback NPC plane:", fallbackPlane);
                return fallbackPlane;
            }
        }

        // Add a function to format the score with points after every three digits
        function formatScore(score) {
            // Convert to string and add points
            return score.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
        }
        
        // Function to update the score display
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${formatScore(score)}`;
        }
        
        // Function to ensure minimum point gain is 500 (always ending with "00")
        function addPoints(amount) {
            try {
                // Debug message with more information
                const oldScore = score;
                
                // Add exactly the amount for all point sources
                const pointsToAdd = amount;
                
                score += pointsToAdd;
                totalScore += pointsToAdd;
                
                // Debug message with score before and after
                console.log(`Adding points: ${amount}, Score: ${oldScore} → ${score}, Trail type: ${window.currentTrailType || 'normal'}`);
                
                try {
                    updateScoreDisplay();
                } catch (e) {
                    console.error("Error updating score display:", e);
                }
                
                try {
                    updateUpgrades();
                } catch (e) {
                    console.error("Error updating upgrades:", e);
                }
                
                // Create point indicators for every 500 points
                try {
                    // Only create indicators for non-trail points (bonuses, etc.)
                    // Trail points already have their own indicators
                    if (!window.currentTrailType) {
                        // Limit the number of indicators to prevent performance issues
                        // Create at most 5 indicators regardless of point amount
                        const maxIndicators = 5;
                        const numIndicators = Math.min(maxIndicators, Math.floor(pointsToAdd / 500));
                        
                        // Only check trail type if player exists
                        if (typeof player !== 'undefined' && player) {
                            // Create indicators only if player exists and messages array exists
                            if (Array.isArray(messages)) {
                                // Limit the total number of messages to prevent performance issues
                                if (messages.length < 100) { // Only create new messages if we have fewer than 100
                                    for (let i = 0; i < numIndicators; i++) {
                                        // Random position near the player
                                        const offsetX = Math.random() * 100 - 50;
                                        const offsetY = Math.random() * 100 - 50;
                                        
                                        // Create a message that floats upward
                                        try {
                                            messages.push(new Message(
                                                "+500", 
                                                player.x + offsetX, 
                                                player.y + offsetY, 
                                                '#ffffff', // White color for non-trail bonuses
                                                20, 
                                                60
                                            ));
                                        } catch (e) {
                                            console.error("Error creating message:", e);
                                        }
                                    }
                                } else {
                                    console.log("Too many messages, skipping point indicators");
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("Error creating point indicators:", e);
                }
                
                return pointsToAdd;
            } catch (e) {
                console.error("Error in addPoints function:", e);
                return amount; // Return original amount in case of error
            }
        }

        // Function to create a backup of the current file in backups folder
        function createBackup() {
            try {
                // Get current date/time for timestamp
                const now = new Date();
                const timestamp = now.getFullYear() +
                    ('0' + (now.getMonth() + 1)).slice(-2) +
                    ('0' + now.getDate()).slice(-2) + '_' +
                    ('0' + now.getHours()).slice(-2) +
                    ('0' + now.getMinutes()).slice(-2) +
                    ('0' + now.getSeconds()).slice(-2);
                
                // Create a backup of the file
                const backupFile = `backups/index_with_fixed_trail_bonus_${timestamp}.html`;
                console.log(`Creating backup at ${backupFile}`);
                
                // The actual backup is done by the server
                const backupRequest = new XMLHttpRequest();
                backupRequest.open('POST', `/create-backup?filename=${backupFile}`, true);
                backupRequest.send();
            } catch (e) {
                console.error("Failed to create backup:", e);
            }
        }
        
        // Create a backup when the game starts
        createBackup();
    </script>
</body>
</html>
